{
  "language": "Solidity",
  "sources": {
    "contracts/dreamers/CandyShop.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Pausable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../interfaces/ICandyShop.sol\";\n\ncontract CandyShop is ERC1155Pausable, Ownable, ReentrancyGuard, ICandyShop {\n    struct SKU {\n        uint256 id;\n        uint256 price;\n        string name;\n    }\n\n    struct SKUInput {\n        uint256 price;\n        string name;\n    }\n\n    mapping(uint256 => SKU) public inventory;\n    mapping(string => uint256) public skuIds;\n    bytes32[] names;\n    address public chainDreamersAddress;\n\n    function addSku(SKUInput[] memory _skus) external onlyOwner {\n        for (uint256 i = 0; i < _skus.length; i++) {\n            if (names.length > 0) {\n                require(\n                    names[skuIds[_skus[i].name]] !=\n                        keccak256(bytes(_skus[i].name)),\n                    \"Sku already exists\"\n                );\n            }\n            uint256 tokenId = names.length;\n            skuIds[_skus[i].name] = tokenId;\n            names.push(keccak256(bytes(_skus[i].name)));\n            inventory[tokenId] = SKU(tokenId, _skus[i].price, _skus[i].name);\n        }\n    }\n\n    function setChainDreamersAddress(address _chainDreamersAddress)\n        external\n        onlyOwner\n    {\n        chainDreamersAddress = _chainDreamersAddress;\n    }\n\n    function mint(uint256 tokenId, uint256 amount)\n        external\n        payable\n        nonReentrant\n    {\n        require(tokenId < names.length, \"This candy does not exist yet\");\n        require(\n            msg.value == inventory[tokenId].price * amount,\n            \"You have to pay the price to eat candies\"\n        );\n        _mint(_msgSender(), tokenId, amount, \"\");\n        setApprovalForAll(chainDreamersAddress, true);\n    }\n\n    function mintBatch(uint256[] calldata tokenIds, uint256[] calldata amounts)\n        external\n        payable\n        nonReentrant\n    {\n        uint256 price;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                tokenIds[i] < names.length,\n                \"This candy does not exist yet\"\n            );\n            price += inventory[tokenIds[i]].price * amounts[i];\n        }\n\n        require(msg.value == price, \"You have to pay the price to eat candies\");\n\n        _mintBatch(_msgSender(), tokenIds, amounts, \"\");\n        setApprovalForAll(chainDreamersAddress, true);\n    }\n\n    function burn(\n        address from,\n        uint256 tokenId,\n        uint256 amount\n    ) external override nonReentrant {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _burn(from, tokenId, amount);\n    }\n\n    function burnBatch(\n        address from,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external override nonReentrant {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _burnBatch(from, tokenIds, amounts);\n    }\n\n    constructor(string memory uri_) ERC1155(uri_) {}\n\n    receive() external payable {}\n\n    function withdraw() public onlyOwner {\n        (bool success, ) = _msgSender().call{value: address(this).balance}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/interfaces/ICandyShop.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ICandyShop {\n    function burnBatch(\n        address from,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external;\n\n    function burn(\n        address from,\n        uint256 tokenId,\n        uint256 amount\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/dreamers/ChainDreamers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {ERC721Enumerable, ERC721} from \"../tokens/ERC721Enumerable.sol\";\nimport \"../interfaces/IDreamersRenderer.sol\";\nimport \"../interfaces/ICandyShop.sol\";\nimport \"../interfaces/IChainRunners.sol\";\n\ncontract OpenSeaProxyRegistry {\n    mapping(address => address) public proxies;\n}\n\ncontract ChainDreamers is ERC721Enumerable, Ownable, ReentrancyGuard {\n    // Linked contracts\n    address public renderingContractAddress;\n    address public candyShopAddress;\n    address public chainRunnersAddress;\n    IDreamersRenderer renderer;\n    ICandyShop candyShop;\n    IChainRunners chainRunners;\n\n    uint8[MAX_NUMBER_OF_TOKENS] public dreamersCandies;\n    uint8 private constant candyMask = 252; // \"11111100\" binary string, last 2 bits kept for candyId\n    /// @dev Copied from \\@naomsa's contract\n    /// @notice OpenSea proxy registry.\n    address public opensea;\n    /// @notice LooksRare marketplace transfer manager.\n    address public looksrare;\n    /// @notice Check if marketplaces pre-approve is enabled.\n    bool public marketplacesApproved = true;\n\n    mapping(address => bool) proxyToApproved;\n\n    /// @notice Set opensea to `opensea_`.\n    function setOpensea(address opensea_) external onlyOwner {\n        opensea = opensea_;\n    }\n\n    /// @notice Set looksrare to `looksrare_`.\n    function setLooksrare(address looksrare_) external onlyOwner {\n        looksrare = looksrare_;\n    }\n\n    /// @notice Toggle pre-approve feature state for sender.\n    function toggleMarketplacesApproved() external onlyOwner {\n        marketplacesApproved = !marketplacesApproved;\n    }\n\n    /// @notice Approve the communication and interaction with cross-collection interactions.\n    function flipProxyState(address proxyAddress) public onlyOwner {\n        proxyToApproved[proxyAddress] = !proxyToApproved[proxyAddress];\n    }\n\n    /// @dev Modified for opensea and looksrare pre-approve so users can make truly gas less sales.\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        if (!marketplacesApproved)\n            return super.isApprovedForAll(owner, operator);\n\n        return\n            operator == OpenSeaProxyRegistry(opensea).proxies(owner) ||\n            operator == looksrare ||\n            proxyToApproved[operator] ||\n            super.isApprovedForAll(owner, operator);\n    }\n\n    // Constants\n    uint256 public maxDreamersMintPublicSale;\n    uint256 public constant MINT_PUBLIC_PRICE = 0.05 ether;\n    uint256 public constant MAX_MINT_FOUNDERS = 50;\n    bool public foundersMinted = false;\n\n    // State variables\n    uint256 public publicSaleStartTimestamp;\n\n    function setPublicSaleTimestamp(uint256 timestamp) external onlyOwner {\n        publicSaleStartTimestamp = timestamp;\n    }\n\n    function isPublicSaleOpen() public view returns (bool) {\n        return\n            block.timestamp > publicSaleStartTimestamp &&\n            publicSaleStartTimestamp != 0;\n    }\n\n    modifier whenPublicSaleActive() {\n        require(isPublicSaleOpen(), \"Public sale not open\");\n        _;\n    }\n\n    function setRenderingContractAddress(address _renderingContractAddress)\n        public\n        onlyOwner\n    {\n        renderingContractAddress = _renderingContractAddress;\n        renderer = IDreamersRenderer(renderingContractAddress);\n    }\n\n    function setCandyShopAddress(address _candyShopContractAddress)\n        public\n        onlyOwner\n    {\n        candyShopAddress = _candyShopContractAddress;\n        candyShop = ICandyShop(candyShopAddress);\n    }\n\n    function setMaxDreamersMintPublicSale(uint256 _maxDreamersMintPublicSale)\n        public\n        onlyOwner\n    {\n        maxDreamersMintPublicSale = _maxDreamersMintPublicSale;\n    }\n\n    function setChainRunnersContractAddress(\n        address _chainRunnersContractAddress\n    ) public onlyOwner {\n        chainRunnersAddress = _chainRunnersContractAddress;\n        chainRunners = IChainRunners(_chainRunnersContractAddress);\n    }\n\n    constructor(string memory name_, string memory symbol_)\n        ERC721(name_, symbol_)\n    {}\n\n    /// @dev This mint function wraps the safeMintBatch to:\n    ///      1) check that the minter owns the runner 2) use the candies 3) burn the candies\n    /// @param tokenIds a bytes interpreted as an array of uint16\n    /// @param candyIds the same indexes as above but as a uint8 array\n    /// @param candyAmounts should be an array of 1\n    function mintBatchRunnersAccess(\n        bytes calldata tokenIds,\n        uint256[] calldata candyIds,\n        uint256[] calldata candyAmounts\n    ) public nonReentrant returns (bool) {\n        require(\n            tokenIds.length == candyIds.length * 2,\n            \"Each runner needs one and only one candy\"\n        );\n\n        safeMintBatch(_msgSender(), tokenIds);\n\n        bytes32 candies = keccak256(\n            abi.encodePacked(\n                tokenIds,\n                msg.sender,\n                candyIds,\n                block.timestamp,\n                block.difficulty\n            )\n        );\n        for (uint256 i = 0; i < candyIds.length; i++) {\n            uint16 tokenId = BytesLib.toUint16(tokenIds, i * 2);\n            // ownerOf uses a simple mapping in OZ's ERC721 so should be cheap\n            require(\n                chainRunners.ownerOf(tokenId) == _msgSender(),\n                \"You cannot give candies to a runner that you do not own\"\n            );\n            require(\n                candyAmounts[i] == 1,\n                \"Your runner needs one and only one candy, who knows what could happen otherwise\"\n            );\n            dreamersCandies[tokenId] =\n                (uint8(candies[i % 32]) & candyMask) +\n                (uint8(candyIds[i]) % 4);\n            if (i % 32 == 31) {\n                candies = keccak256(abi.encodePacked(candies));\n            }\n        }\n\n        candyShop.burnBatch(_msgSender(), candyIds, candyAmounts);\n        return true;\n    }\n\n    function mintBatchPublicSale(bytes calldata tokenIds)\n        public\n        payable\n        nonReentrant\n        whenPublicSaleActive\n        returns (bool)\n    {\n        require(\n            (tokenIds.length / 2) * MINT_PUBLIC_PRICE == msg.value,\n            \"You have to pay the bail bond\"\n        );\n        require(\n            ERC721.balanceOf(_msgSender()) + tokenIds.length / 2 <=\n                maxDreamersMintPublicSale,\n            \"Your home is to small to welcome so many dreamers\"\n        );\n        safeMintBatch(_msgSender(), tokenIds);\n\n        bytes32 candies = keccak256(\n            abi.encodePacked(\n                tokenIds,\n                msg.sender,\n                msg.value,\n                block.timestamp,\n                block.difficulty\n            )\n        );\n        for (uint256 i = 0; i < tokenIds.length; i += 2) {\n            uint16 tokenId = BytesLib.toUint16(tokenIds, i);\n            dreamersCandies[tokenId] = uint8(candies[i / 2]);\n        }\n\n        return true;\n    }\n\n    function mintBatchFounders(bytes calldata tokenIds)\n        public\n        nonReentrant\n        onlyOwner\n        whenPublicSaleActive\n        returns (bool)\n    {\n        require(!foundersMinted, \"Don't be too greedy\");\n        require(\n            tokenIds.length <= MAX_MINT_FOUNDERS * 2,\n            \"Even if you are a founder, you don't deserve that many Dreamers\"\n        );\n        safeMintBatch(_msgSender(), tokenIds);\n\n        bytes32 candies = keccak256(\n            abi.encodePacked(\n                tokenIds,\n                msg.sender,\n                block.timestamp,\n                block.difficulty\n            )\n        );\n        for (uint256 i = 0; i < tokenIds.length / 2; i++) {\n            uint16 tokenId = BytesLib.toUint16(tokenIds, i * 2);\n            dreamersCandies[tokenId] = uint8(candies[i % 32]);\n            if (i % 32 == 31) {\n                candies = keccak256(abi.encodePacked(candies));\n            }\n        }\n        foundersMinted = true;\n        return true;\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(uint16(_tokenId)),\n            \"ERC721: URI query for nonexistent token\"\n        );\n\n        if (renderingContractAddress == address(0)) {\n            return \"\";\n        }\n\n        return renderer.tokenURI(_tokenId, dreamersCandies[_tokenId]);\n    }\n\n    receive() external payable {}\n\n    function withdraw() public onlyOwner {\n        (bool success, ) = _msgSender().call{value: address(this).balance}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts/tokens/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ERC721} from \"./ERC721.sol\";\nimport {IERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token optimized for batch minting with enumerable interface\n * @notice a bytes2 (uint16) is used to store the token id so the collection should be lower than 2^16 = 65536 items\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n *      Based on the study for writing indexes and addresses, we use a single mapping for storing all the data\n *      We use the uint16 / bytes2 tokenId\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    function totalSupply() external view override returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i < owners.length; i += 20) {\n            total += _balanceOf(i);\n        }\n        return total;\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        override\n        returns (uint256 tokenId)\n    {\n        require(\n            index * 2 < _tokensByOwner[owner].length,\n            \"ERC721Enumerable: index out of range\"\n        );\n        return BytesLib.toUint16(_tokensByOwner[owner], index * 2);\n    }\n\n    function tokenByIndex(uint256 index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 ownerIndex = 0;\n        uint256 count;\n        while (count <= index) {\n            count += _balanceOf(ownerIndex);\n            ownerIndex += 20;\n        }\n        ownerIndex -= 20;\n        count -= _balanceOf(ownerIndex);\n        return\n            BytesLib.toUint16(\n                _tokensByOwner[BytesLib.toAddress(owners, ownerIndex)],\n                (index - count) * 2\n            );\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IERC165, ERC721)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/interfaces/IDreamersRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IDreamersRenderer {\n    function tokenURI(uint256 tokenId, uint8 candy)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/interfaces/IChainRunners.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IChainRunners {\n    function getDna(uint256 _tokenId) external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n}\n"
    },
    "contracts/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token optimized for batch minting\n * @notice a bytes2 (uint16) is used to store the token id so the collection should be lower than 2^16 = 65536 items\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n *      Based on the study for writing indexes and addresses, we use a single mapping for storing all the data\n *      We use the uint16 / bytes2 tokenId\n */\nabstract contract ERC721 is IERC721, IERC721Metadata, Context, ERC165 {\n    using Address for address;\n\n    // Mapping from address to tokenIds. This is the single source of truth for the data\n    mapping(address => bytes) internal _tokensByOwner;\n\n    // Because mapping in solidity are not real hash tables, one needs to keep track of the keys.\n    // One address is 20 bytes\n    bytes internal owners;\n\n    // Number of tokens\n    uint16 public constant MAX_NUMBER_OF_TOKENS = 10_000;\n\n    // Bool array to store if the token is minted. To save on gas for token lookup in _tokensByOwner.\n    bool[MAX_NUMBER_OF_TOKENS] internal tokenExists;\n\n    // Mapping from token ID to approved address\n    mapping(uint16 => address) internal _tokenApprovals;\n\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev There are two bytes per tokenId\n     * @param owner address The address we retrieve the balance for\n     * @return uint256 The number of tokens owned by the address\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        return _tokensByOwner[owner].length / 2;\n    }\n\n    function _balanceOf(uint256 ownerIndex) internal view returns (uint256) {\n        require(ownerIndex < owners.length, \"ERC721: ownerIndex out of bound\");\n        return balanceOf(BytesLib.toAddress(owners, ownerIndex));\n    }\n\n    /// @dev Returns the index of owner in the internal array of owners. Revert if not found.\n    /// @param owner address The address we retrieve the index for\n    function getOwnerIndex(address owner) public view returns (uint256) {\n        uint256 index = 0;\n        while (index < owners.length) {\n            if (BytesLib.toAddress(owners, index) == owner) {\n                return index / 20;\n            }\n            index += 20;\n        }\n        revert(\"ERC721: Owner not found\");\n    }\n\n    /// @dev Returns the array of bool telling if a token exists or not.\n    function getTokenExists()\n        external\n        view\n        returns (bool[MAX_NUMBER_OF_TOKENS] memory)\n    {\n        return tokenExists;\n    }\n\n    /**\n     * @param tokenId uint16 A given token id\n     * @return bool True if the token exists, false otherwise\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return tokenExists[tokenId];\n    }\n\n    /**\n     * @dev This is copied from OpenZeppelin's implementation\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    _msgSender(),\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ERC721: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /// @dev This is the core unsafe implementation of a transfer.\n    /// @param from address The address which you want to transfer the token from\n    /// @param fromIndex uint256 The index of \"from\" in the owners bytes. This is to avoid a search in the array.\n    /// @param to address The address which you want to transfer the token to\n    /// @param tokenIndex uint256 The index of the token to transfer in the from's token list.\n    function _transfer(\n        address from,\n        uint256 fromIndex,\n        address to,\n        uint256 tokenIndex\n    ) private {\n        require(\n            BytesLib.toAddress(owners, fromIndex * 20) == from,\n            \"ERC721: transfer from address is invalid\"\n        );\n        if (_tokensByOwner[to].length == 0) {\n            owners = bytes.concat(owners, bytes20(to));\n        }\n        bytes memory tokenId = BytesLib.slice(\n            _tokensByOwner[from],\n            tokenIndex,\n            tokenIndex + 2\n        );\n        if (_tokensByOwner[from].length == 2) {\n            owners = bytes.concat(\n                BytesLib.slice(owners, 0, fromIndex * 20),\n                BytesLib.slice(\n                    owners,\n                    (fromIndex + 1) * 20,\n                    owners.length - (fromIndex + 1) * 20\n                )\n            );\n            delete _tokensByOwner[from];\n        } else {\n            _tokensByOwner[from] = bytes.concat(\n                BytesLib.slice(_tokensByOwner[from], 0, tokenIndex),\n                BytesLib.slice(\n                    _tokensByOwner[from],\n                    tokenIndex + 2,\n                    _tokensByOwner[from].length - tokenIndex - 2\n                )\n            );\n        }\n        _tokensByOwner[to] = bytes.concat(_tokensByOwner[to], tokenId);\n        emit Transfer(from, to, BytesLib.toUint16(tokenId, 0));\n    }\n\n    /// @dev Transfer token with minimal computing since all the required data to check is given\n    /// @param from address The address which you want to transfer the token from\n    /// @param fromIndex uint256 The index of \"from\" in the owners bytes. This is to avoid a search in the array.\n    /// @param to address The address which you want to transfer the token to\n    /// @param tokenIndex uint256 The index of the token to transfer in the from's token list.\n    function safeTransferFrom(\n        address from,\n        uint256 fromIndex,\n        address to,\n        uint256 tokenIndex\n    ) external {\n        require(from != address(0), \"ERC721: from cannot be the zero address\");\n        require(to != address(0), \"ERC721: to cannot be the zero address\");\n        require(\n            tokenIndex < _tokensByOwner[from].length / 2,\n            \"ERC721: token index out of range\"\n        );\n        uint16 tokenId = BytesLib.toUint16(\n            _tokensByOwner[from],\n            tokenIndex * 2\n        );\n        require(\n            _tokenApprovals[tokenId] == msg.sender || from == msg.sender,\n            \"ERC721: caller is neither approved nor owner\"\n        );\n        _transfer(from, fromIndex, to, tokenIndex);\n        _checkOnERC721Received(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev This is the core unsafe implementation of a mint.\n     * @param to address The receiver of the tokens\n     * @param tokenIds bytes The token ids to mint\n     */\n    function _mintBatch(address to, bytes calldata tokenIds) private {\n        require(tokenIds.length > 0, \"ERC721: cannot mint with no token Ids\");\n        require(\n            tokenIds.length % 2 == 0,\n            \"ERC721: tokenIds should be bytes of uint16\"\n        );\n        if (_tokensByOwner[to].length == 0) {\n            owners = bytes.concat(owners, bytes20(to));\n        }\n        for (uint256 i = 0; i < tokenIds.length; i += 2) {\n            require(\n                !tokenExists[BytesLib.toUint16(tokenIds, i)],\n                \"ERC721: token already exists\"\n            );\n            tokenExists[BytesLib.toUint16(tokenIds, i)] = true;\n            emit Transfer(address(0), to, BytesLib.toUint16(tokenIds, i));\n        }\n        _tokensByOwner[to] = bytes.concat(_tokensByOwner[to], tokenIds);\n    }\n\n    /// @dev Add a batch of token Ids given as a bytes array to the sender\n    /// @param to address minting token to this address\n    /// @param tokenIds bytes a bytes of tokenIds as bytes2 (uint16)\n    function safeMintBatch(address to, bytes calldata tokenIds)\n        internal\n        virtual\n    {\n        _mintBatch(to, tokenIds);\n        _checkOnERC721Received(\n            address(0),\n            to,\n            BytesLib.toUint16(tokenIds, 0),\n            \"\"\n        );\n    }\n\n    /// @dev Approve \"to\" to manage token Id\n    /// @param to address The address which will manage the token Id\n    /// @param tokenId uint256 The token Id to manage\n    /// @param tokenIndex uint256 The index of the token in the owner's list\n    function approve(\n        address to,\n        uint256 tokenId,\n        uint256 tokenIndex\n    ) external {\n        if (_tokenApprovals[uint16(tokenId)] != msg.sender) {\n            // if sender is not approved, they need to be the owner\n            require(\n                tokenIndex * 2 < _tokensByOwner[msg.sender].length,\n                \"ERC721: token index out of range\"\n            );\n            require(\n                BytesLib.toUint16(_tokensByOwner[msg.sender], tokenIndex * 2) ==\n                    tokenId,\n                \"ERC721: caller is neither approved nor owner\"\n            );\n            emit Approval(msg.sender, to, tokenId);\n        }\n        _tokenApprovals[uint16(tokenId)] = to;\n    }\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId)\n        external\n        view\n        override\n        returns (address)\n    {\n        require(_exists(tokenId), \"ERC721: token does not exist\");\n        return _tokenApprovals[uint16(tokenId)];\n    }\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     * @param operator The address of the operator to add or remove.\n     * @param _approved Whether to add or remove `operator` as an operator.\n     */\n    function setApprovalForAll(address operator, bool _approved)\n        external\n        override\n    {\n        require(\n            operator != msg.sender,\n            \"ERC721: cannot approve caller as operator\"\n        );\n        bytes memory tokens = _tokensByOwner[msg.sender];\n        for (uint256 i = 0; i < tokens.length; i += 2) {\n            _tokenApprovals[BytesLib.toUint16(tokens, i)] = _approved\n                ? operator\n                : address(0);\n        }\n\n        emit ApprovalForAll(msg.sender, operator, _approved);\n    }\n\n    /**\n     * @dev Returns whether `operator` is an approved operator for the caller.\n     * @param owner The address of the owner to check.\n     * @param operator The address of the operator to check.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        bytes memory tokens = _tokensByOwner[owner];\n        for (uint256 i = 0; i < tokens.length; i += 2) {\n            if (_tokenApprovals[BytesLib.toUint16(tokens, i)] != operator) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // Functions that should not be used but here for compatibility with ERC721\n    // These are gassy.\n    ///////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        require(from != address(0), \"ERC721: from cannot be the zero address\");\n        require(to != address(0), \"ERC721: to cannot be the zero address\");\n        require(\n            _tokenApprovals[uint16(tokenId)] == msg.sender ||\n                from == msg.sender,\n            \"ERC721: caller is not approved for all tokens\"\n        );\n        uint256 tokenIndex = 0;\n        while (\n            BytesLib.toUint16(_tokensByOwner[from], tokenIndex) != tokenId &&\n            tokenIndex < _tokensByOwner[from].length\n        ) {\n            tokenIndex += 2;\n        }\n        require(\n            tokenIndex < _tokensByOwner[from].length,\n            \"ERC721: from does not own the token\"\n        );\n\n        uint256 fromIndex;\n        for (fromIndex = 0; fromIndex < owners.length; fromIndex += 20) {\n            if (BytesLib.toAddress(owners, fromIndex) == from) {\n                break;\n            }\n        }\n        require(\n            BytesLib.toAddress(owners, fromIndex) == from,\n            \"ERC721: from is not in owners list\"\n        );\n        _transfer(from, fromIndex, to, tokenIndex);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external override {\n        _safeTransferFrom(from, to, tokenId, bytes(\"\"));\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external override {\n        _safeTransferFrom(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external override {\n        require(from != address(0), \"ERC721: from cannot be the zero address\");\n        require(to != address(0), \"ERC721: to cannot be the zero address\");\n        require(\n            _tokenApprovals[uint16(tokenId)] == msg.sender ||\n                from == msg.sender,\n            \"ERC721: caller is not approved for all tokens\"\n        );\n        uint256 tokenIndex = 0;\n        while (\n            BytesLib.toUint16(_tokensByOwner[from], tokenIndex) != tokenId &&\n            tokenIndex < _tokensByOwner[from].length\n        ) {\n            tokenIndex += 2;\n        }\n        require(\n            tokenIndex < _tokensByOwner[from].length,\n            \"ERC721: from does not own the token\"\n        );\n\n        uint256 fromIndex;\n        for (fromIndex = 0; fromIndex < owners.length; fromIndex += 20) {\n            if (BytesLib.toAddress(owners, fromIndex) == from) {\n                break;\n            }\n        }\n        require(\n            BytesLib.toAddress(owners, fromIndex) == from,\n            \"ERC721: from is not in owners list\"\n        );\n        _transfer(from, fromIndex, to, tokenIndex);\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev For each owner, we go through all their tokens and check if the sought token is in the list. This lookup\n     *      is gassy but we do not expect to pay them often as we provide other mean of doing the transfers.\n     * @param tokenId uint16 A given token id\n     * @return address The owner of the token, might be 0x0 if not found\n     */\n    function _ownerOf(uint256 tokenId) private view returns (address) {\n        address owner = address(0);\n        for (uint256 i = 0; i < owners.length; i += 20) {\n            address currentOwner = BytesLib.toAddress(owners, i);\n            for (\n                uint256 j = 0;\n                j < _tokensByOwner[currentOwner].length;\n                j += 2\n            ) {\n                if (\n                    BytesLib.toUint16(_tokensByOwner[currentOwner], j) ==\n                    tokenId\n                ) {\n                    owner = currentOwner;\n                    break;\n                }\n            }\n            if (owner != address(0)) {\n                break;\n            }\n        }\n        return owner;\n    }\n\n    /**\n     * @dev This is the public ownerOf, see IERC721. We fail fast with the initial check. There is no good\n     *      reason to call this function on chain.\n     * @param tokenId uint265 A given token id\n     * @return address The owner of the token.\n     */\n    function ownerOf(uint256 tokenId) external view override returns (address) {\n        require(_exists(tokenId), \"ERC721: owner query for nonexistent token\");\n        return _ownerOf(tokenId);\n    }\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external override {\n        address owner = _ownerOf(tokenId);\n        require(\n            owner != address(0),\n            \"ERC721: approve query for nonexistent token\"\n        );\n        require(\n            _tokenApprovals[uint16(tokenId)] == msg.sender ||\n                owner == msg.sender,\n            \"ERC721: caller is not the owner nor an approved operator for the token\"\n        );\n        _tokenApprovals[uint16(tokenId)] = to;\n        emit Approval(owner, to, tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/dreamers/DreamersRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@0xsequence/sstore2/contracts/SSTORE2.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport {Integers} from \"../lib/Integers.sol\";\nimport \"./ChainRunnersConstants.sol\";\n\nimport \"../interfaces/IChainRunners.sol\";\nimport \"../interfaces/IDreamersRenderer.sol\";\n\n/*  @title Dreamers Renderer\n    @author Clement Walter\n    @dev Leverage the d attributes of svg <path> to encode a palette of base traits. Each runner trait\n         is encoded as a combination of these base traits. More precisely, the Dreamers encoding scheme works as follows:\n         - each one of the 330 traits is encoded as a list of <path />\n         - each path combines a `d` and a `fill`\n         - the storage contains the all the possible `d` and all the possible `fill`\n         - each trait is then an ordered list of tuples (index of d, index of fill)\n         - each dreamer is a list a trait and consequently still an ordered list of (index of d, index of fill)\n*/\ncontract DreamersRenderer is\n    IDreamersRenderer,\n    Ownable,\n    ReentrancyGuard,\n    ChainRunnersConstants\n{\n    using Integers for uint8;\n    using Strings for uint256;\n\n    // We have a total of 3 bytes = 24 bits per Path\n    uint8 public constant BITS_PER_D_INDEX = 12;\n    uint8 public constant BITS_PER_FILL_INDEX = 12;\n\n    // Each D is encoded with a sequence of 2 bits for each letter (M, L, Q, C) and 1 byte per attribute. Since each\n    // letter does not have the same number of attributes, this number if stored as constant below as well.\n    uint8 public constant BITS_PER_D_ATTRIBUTE = 3;\n    bytes8 public constant D_ATTRIBUTE_PALETTE = hex\"4d4c51434148565a\"; // M L Q C A H V Z\n    bytes8 public constant D_ATTRIBUTE_PARAMETERS_COUNT = hex\"0202040607010100\"; // 2 2 4 6 7 1 1 0\n    bytes3 public constant NONE_COLOR = hex\"000001\";\n    bytes public constant PATH_TAG_START = bytes(\"%3cpath%20d='\");\n    bytes public constant FILL_TAG = bytes(\"'%20fill='\");\n    bytes public constant STROKE_TAG = bytes(\"'%20stroke='%23000\");\n    bytes public constant PATH_TAG_END = bytes(\"'/%3e\");\n    bytes public constant HASHTAG = bytes(\"%23\");\n    bytes public constant SPACE = bytes(\"%20\");\n    bytes public constant SVG_TAG_START =\n        bytes(\n            \"%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20255%20255'%20width='500px'%20height='500px'%3e\"\n        );\n    bytes public constant SVG_TAG_END =\n        bytes(\"%3cstyle%3epath{stroke-width:0.71}%3c/style%3e%3c/svg%3e\");\n\n    struct Trait {\n        uint16 dIndex;\n        uint16 fillIndex;\n        bool stroke;\n    }\n\n    address public fillPalette;\n    address[] public dPalette;\n    address public dPaletteIndexes;\n    address public traitPalette;\n    address public traitPaletteIndexes;\n    bytes layerIndexes;\n    IChainRunners runnersToken;\n\n    ////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////  Rendering mechanics  /////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////\n    /// @dev Colors are concatenated and stored in a single 'bytes' with SSTORE2 to save gas.\n    function setFillPalette(bytes calldata _fillPalette) external onlyOwner {\n        fillPalette = SSTORE2.write(_fillPalette);\n    }\n\n    /// @dev Only the d parameter is encoded for each path. All the paths are concatenated together to save gas.\n    ///      The dPaletteIndexes is used to retrieve the path from the dPalette.\n    function setDPalette(bytes[] calldata _pathPalette) external onlyOwner {\n        for (uint8 i = 0; i < _pathPalette.length; i++) {\n            dPalette.push(SSTORE2.write(_pathPalette[i]));\n        }\n    }\n\n    /// @dev Since each SSTORE2 slots can contain up to 24kb, indexes need to be uint16, ie. two bytes per index.\n    function setDPaletteIndex(bytes calldata _pathPaletteIndex)\n        external\n        onlyOwner\n    {\n        dPaletteIndexes = SSTORE2.write(_pathPaletteIndex);\n    }\n\n    /// @dev The traits are stored as a list of tuples (d index, fill index). For our case, 12 bits per index is\n    ///      enough as 2^12 = 4096 is greater than total number of d and total number of fill to date.\n    ///      This could be changed if needed.\n    ///      Hence a trait is a sequence of several 3 bytes long (d index, fill index).\n    function setTraitPalette(bytes calldata _traitPalette) external onlyOwner {\n        traitPalette = SSTORE2.write(_traitPalette);\n    }\n\n    /// @dev Since each SSTORE2 slots can contain up to 24kb, indexes need to be uint16, ie. two bytes per index.\n    ///      A trait can then be retrieved with traitPalette[traitPaletteIndexes[i]: traitPaletteIndexes[i+1]]\n    function setTraitPaletteIndex(bytes calldata _traitPaletteIndex)\n        external\n        onlyOwner\n    {\n        traitPaletteIndexes = SSTORE2.write(_traitPaletteIndex);\n    }\n\n    /// @dev The trait indexes allow to map from the Chain Runners 2D indexation (trait index, layer index) to the\n    ///      current 1D indexation (trait index).\n    function setLayerIndexes(bytes calldata _layerIndexes) external onlyOwner {\n        layerIndexes = _layerIndexes;\n    }\n\n    /// @dev This function will be the pendant of the ChainRunnersBaseRenderer.getLayer ones.\n    function getTraitIndex(uint16 _layerIndex, uint16 _itemIndex)\n        public\n        view\n        returns (uint16)\n    {\n        uint16 traitIndex = BytesLib.toUint16(layerIndexes, _layerIndex * 2);\n        uint16 nextTraitIndex = BytesLib.toUint16(\n            layerIndexes,\n            (_layerIndex + 1) * 2\n        );\n        if (traitIndex + _itemIndex > nextTraitIndex - 1) {\n            return type(uint16).max;\n        }\n\n        return traitIndex + _itemIndex;\n    }\n\n    /// @dev 3 bytes per color because svg does not handle alpha.\n    function getFill(uint16 _index) public view returns (string memory) {\n        // TODO: use assembly instead\n        bytes memory palette = SSTORE2.read(fillPalette);\n        if (\n            palette[(_index * 3)] == NONE_COLOR[0] &&\n            palette[(_index * 3) + 1] == NONE_COLOR[1] &&\n            palette[(_index * 3) + 2] == NONE_COLOR[2]\n        ) {\n            return \"none\";\n        }\n\n        return\n            string(\n                bytes.concat(\n                    HASHTAG,\n                    bytes(uint8(palette[3 * _index]).toString(16, 2)),\n                    bytes(uint8(palette[3 * _index + 1]).toString(16, 2)),\n                    bytes(uint8(palette[3 * _index + 2]).toString(16, 2))\n                )\n            );\n    }\n\n    /// @dev Get the start and end indexes of the bytes concerning the given d in the dPalette storage.\n    function getDIndex(uint16 _index) public view returns (uint32, uint32) {\n        // TODO: use assembly instead\n        bytes memory _indexes = SSTORE2.read(dPaletteIndexes);\n        uint32 start = uint32(BytesLib.toUint16(_indexes, _index * 2));\n        uint32 next = uint32(BytesLib.toUint16(_indexes, _index * 2 + 2));\n        // Magic reasonable number to deal with overflow\n        if (uint32(_index) > 1000 && start < 20000) {\n            start = uint32(type(uint16).max) + 1 + start;\n        }\n        if (uint32(_index) > 2000 && start < 40000) {\n            start = uint32(type(uint16).max) + 1 + start;\n        }\n        if (uint32(_index) > 1000 && next < 20000) {\n            next = uint32(type(uint16).max) + 1 + next;\n        }\n        if (uint32(_index) > 2000 && next < 40000) {\n            next = uint32(type(uint16).max) + 1 + next;\n        }\n        return (start, next);\n    }\n\n    /// @dev Retrieve the bytes for the given d from the dPalette storage. The bytes may be split into several SSTORE2\n    ///      slots.\n    function getDBytes(uint16 _index) public view returns (bytes memory) {\n        // TODO: use assembly instead\n        (uint32 dIndex, uint32 dIndexNext) = getDIndex(_index);\n        uint256 storageIndex = 0;\n        bytes memory _dPalette = SSTORE2.read(dPalette[storageIndex]);\n        uint256 cumSumBytes = _dPalette.length;\n        uint256 pos = dIndex;\n        while (dIndex > cumSumBytes - 1) {\n            pos -= _dPalette.length;\n            storageIndex++;\n            _dPalette = SSTORE2.read(dPalette[storageIndex]);\n            cumSumBytes += _dPalette.length;\n        }\n        bytes memory _d = new bytes(dIndexNext - dIndex);\n        for (uint256 i = 0; i < _d.length; i++) {\n            if (pos > _dPalette.length - 1) {\n                storageIndex++;\n                _dPalette = SSTORE2.read(dPalette[storageIndex]);\n                pos = 0;\n            }\n            _d[i] = _dPalette[pos];\n            pos++;\n        }\n        return _d;\n    }\n\n    /// @dev Decodes the path and returns it as a plain string to be used in the svg path attribute.\n    function getD(bytes memory dEncodedBytes)\n        public\n        pure\n        returns (string memory)\n    {\n        bytes memory d;\n        bytes memory bytesBuffer;\n        uint32 bitsShift = 0;\n        uint16 byteIndex = 0;\n        uint8 bitShiftRemainder = 0;\n        uint8 dAttributeIndex;\n        uint8 dAttributeParameterCount;\n        while (\n            bitsShift <= dEncodedBytes.length * 8 - (BITS_PER_D_ATTRIBUTE + 8) // at least BITS_PER_D_ATTRIBUTE bits for the d attribute index and 1 byte for the d attribute parameter count\n        ) {\n            byteIndex = uint16(bitsShift / 8);\n            bitShiftRemainder = uint8(bitsShift % 8);\n\n            dAttributeIndex =\n                uint8(\n                    (dEncodedBytes[byteIndex] << bitShiftRemainder) |\n                        (dEncodedBytes[byteIndex + 1] >>\n                            (8 - bitShiftRemainder))\n                ) >>\n                (8 - BITS_PER_D_ATTRIBUTE);\n\n            dAttributeParameterCount = uint8(\n                D_ATTRIBUTE_PARAMETERS_COUNT[dAttributeIndex]\n            );\n\n            bitsShift += BITS_PER_D_ATTRIBUTE;\n            byteIndex = uint16(bitsShift / 8);\n            bitShiftRemainder = uint8(bitsShift % 8);\n            bytesBuffer = new bytes(dAttributeParameterCount);\n            // TODO: use assembly instead\n            for (uint8 i = 0; i < dAttributeParameterCount; i++) {\n                bytesBuffer[i] =\n                    dEncodedBytes[byteIndex + i] <<\n                    bitShiftRemainder;\n                if (byteIndex + i + 1 < dEncodedBytes.length) {\n                    bytesBuffer[i] |=\n                        dEncodedBytes[byteIndex + i + 1] >>\n                        (8 - bitShiftRemainder);\n                }\n            }\n\n            d = bytes.concat(\n                d,\n                D_ATTRIBUTE_PALETTE[dAttributeIndex],\n                bytes(uint8(bytesBuffer[0]).toString())\n            );\n            for (uint8 i = 1; i < dAttributeParameterCount; i++) {\n                d = bytes.concat(\n                    d,\n                    SPACE,\n                    bytes(uint8(bytesBuffer[i]).toString())\n                );\n            }\n            bitsShift += 8 * dAttributeParameterCount;\n        }\n        return string(d);\n    }\n\n    /// @dev Used to concat all the traits of a given dreamers given the array of trait indexes.\n    function getTraits(uint16[NUM_LAYERS] memory _index)\n        public\n        view\n        returns (Trait[] memory)\n    {\n        // First: retrieve all bytes indexes\n        bytes memory _traitPaletteIndexes = SSTORE2.read(traitPaletteIndexes);\n        bytes memory _traitPalette = SSTORE2.read(traitPalette);\n\n        bytes memory traitsBytes;\n        uint16 start;\n        uint16 next;\n        for (uint16 i = 0; i < NUM_LAYERS; i++) {\n            if (_index[i] == type(uint16).max) {\n                continue;\n            }\n            start = BytesLib.toUint16(_traitPaletteIndexes, _index[i] * 2);\n            next = BytesLib.toUint16(_traitPaletteIndexes, _index[i] * 2 + 2);\n            traitsBytes = bytes.concat(\n                traitsBytes,\n                BytesLib.slice(_traitPalette, start, next - start)\n            );\n        }\n\n        // Second: retrieve all traits\n        bool stroke;\n        Trait[] memory traits = new Trait[](traitsBytes.length / 3);\n        for (uint256 i = 0; i < traitsBytes.length; i += 3) {\n            (uint16 dIndex, uint16 fillIndex) = Integers.load12x2(\n                traitsBytes[i],\n                traitsBytes[i + 1],\n                traitsBytes[i + 2]\n            );\n            stroke = fillIndex % 2 > 0;\n            fillIndex = fillIndex >> 1;\n            traits[i / 3] = Trait(dIndex, fillIndex, stroke);\n        }\n        return traits;\n    }\n\n    /// @notice Useful for returning a single Traits in the Runner's meaning\n    function getTrait(uint16 _index) public view returns (Trait[] memory) {\n        uint16[NUM_LAYERS] memory _indexes;\n        _indexes[0] = _index;\n        for (uint256 i = 1; i < NUM_LAYERS; i++) {\n            _indexes[i] = type(uint16).max;\n        }\n        return getTraits(_indexes);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////  Dreamers  ///////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @dev Each trait is the bytes representation of the final svg string concatenating several <path> elements.\n    function getSvg(Trait[] memory traits) public view returns (string memory) {\n        bytes memory svg = SVG_TAG_START;\n        for (uint16 i = 0; i < traits.length; i++) {\n            svg = bytes.concat(\n                svg,\n                PATH_TAG_START,\n                bytes(getD(getDBytes(traits[i].dIndex))),\n                FILL_TAG,\n                bytes(getFill(traits[i].fillIndex))\n            );\n            if (traits[i].stroke) {\n                svg = bytes.concat(svg, STROKE_TAG);\n            }\n            svg = bytes.concat(svg, PATH_TAG_END);\n        }\n        return string(bytes.concat(svg, SVG_TAG_END));\n    }\n\n    constructor(address _rendererAddress, address _runnersTokenAddress)\n        ChainRunnersConstants(_rendererAddress)\n    {\n        runnersToken = IChainRunners(_runnersTokenAddress);\n    }\n\n    /// @notice The Dreamer's full DNA is an alteration of its corresponding Runner's DNA with it's consumed candy.\n    ///      The candy ids are hardcoded while it should be better to retrieve their effects from the CandyShop\n    ///      contract.\n    /// @dev Somehow copied from the original code but returns an array of trait indexes instead of Layer structs.\n    ///      Flags for no layer is also updated from empty `Layer` to index = type(uint16).max.\n    function getTokenData(uint256 runnerDna, uint8 candy)\n        public\n        view\n        returns (uint16[NUM_LAYERS] memory traitIndexes)\n    {\n        uint16[NUM_LAYERS] memory dna = splitNumber(runnerDna);\n        uint16[NUM_LAYERS] memory candyEffect = splitNumber(\n            uint256(keccak256(abi.encodePacked(candy, dna)))\n        );\n\n        // Get the raceIndex before any updates as the WEIGHTS are not the same for each race but we want to\n        // keep changes tractable in terms of candy effect\n        uint16 raceIndex = chainRunnersBaseRenderer.getRaceIndex(dna[1]);\n\n        if (candy % 4 == 0) {\n            // CHAIN_METH\n            dna[0] = candyEffect[0];\n            dna[6] = candyEffect[6];\n            dna[7] = candyEffect[7];\n            dna[8] = candyEffect[8];\n            dna[10] = candyEffect[10];\n            dna[11] = candyEffect[11];\n            dna[12] = candyEffect[12];\n        } else if (candy % 4 == 1) {\n            // SOMNUS_TEARS\n            dna[1] = candyEffect[1];\n            dna[2] = candyEffect[2];\n            dna[3] = candyEffect[3];\n            dna[4] = candyEffect[4];\n            dna[5] = candyEffect[5];\n            dna[9] = candyEffect[9];\n        }\n\n        bool hasFaceAcc = dna[7] < (NUM_RUNNERS - WEIGHTS[raceIndex][7][7]);\n        bool hasMask = dna[8] < (NUM_RUNNERS - WEIGHTS[raceIndex][8][7]);\n        bool hasHeadBelow = dna[9] < (NUM_RUNNERS - WEIGHTS[raceIndex][9][36]);\n        bool hasHeadAbove = dna[11] <\n            (NUM_RUNNERS - WEIGHTS[raceIndex][11][48]);\n        bool useHeadAbove = (dna[0] % 2) > 0;\n        for (uint8 i = 0; i < NUM_LAYERS; i++) {\n            uint8 layerTraitIndex = chainRunnersBaseRenderer.getLayerIndex(\n                dna[i],\n                i,\n                raceIndex\n            );\n            if ((i == 0) && (candy % 4 == 2)) {\n                // HELIUM_SPICE\n                if (candyEffect[0] % 10 == 0) {\n                    layerTraitIndex = 44;\n                }\n            }\n            uint16 traitIndex = getTraitIndex(i, layerTraitIndex);\n\n            // These conditions help make sure layer selection meshes well visually.\n            // 1. If mask, no face/eye acc/mouth acc\n            // 2. If face acc, no mask/mouth acc/face\n            // 3. If both head above & head below, randomly choose one\n            bool consistencyCheck = (((i == 2 || i == 12) &&\n                !hasMask &&\n                !hasFaceAcc) ||\n                (i == 7 && !hasMask) ||\n                (i == 10 && !hasMask) ||\n                (i < 2 || (i > 2 && i < 7) || i == 8 || i == 9 || i == 11));\n            bool noHeadCheck = ((hasHeadBelow &&\n                hasHeadAbove &&\n                (i == 9 && useHeadAbove)) || (i == 11 && !useHeadAbove));\n            bool isRealTrait = traitIndex < type(uint16).max;\n            if (!isRealTrait || !consistencyCheck || noHeadCheck) {\n                traitIndex = type(uint16).max;\n            }\n            traitIndexes[i] = traitIndex;\n        }\n        return traitIndexes;\n    }\n\n    /// @notice On-chain rendering of any runner with a given candy\n    ///         For on-chain rendering of a given token, retrieve first its candy with `dreamers(tokenId)`\n    ///         and give it here. The output can be directly copied/pasted into the browser bar for displaying the image.\n    function imageURI(uint256 tokenId, uint8 candy)\n        external\n        view\n        returns (string memory)\n    {\n        uint256 runnerDna = runnersToken.getDna(tokenId);\n        uint16[NUM_LAYERS] memory traitIndexes = getTokenData(runnerDna, candy);\n        Trait[] memory traits = getTraits(traitIndexes);\n        return string(abi.encodePacked(\"data:image/svg+xml,\", getSvg(traits)));\n    }\n\n    /// @notice Off-chain rendering because of Twitter, MetaMask, etc.\n    function tokenURI(uint256 tokenId, uint8)\n        external\n        pure\n        override\n        returns (string memory)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    \"https://api.chaindreamers.xyz/test/tokens/\",\n                    tokenId.toString(),\n                    \"/metadata\"\n                )\n            );\n    }\n}\n"
    },
    "@0xsequence/sstore2/contracts/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./utils/Bytecode.sol\";\n\n/**\n  @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.\n  @author Agustin Aguilar <aa@horizon.io>\n\n  Readme: https://github.com/0xsequence/sstore2#readme\n*/\nlibrary SSTORE2 {\n  error WriteError();\n\n  /**\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\n    @dev The pointer is a contract address with `_data` as code\n    @param _data to be written\n    @return pointer Pointer to the written `_data`\n  */\n  function write(bytes memory _data) internal returns (address pointer) {\n    // Append 00 to _data so contract can't be called\n    // Build init code\n    bytes memory code = Bytecode.creationCodeFor(\n      abi.encodePacked(\n        hex'00',\n        _data\n      )\n    );\n\n    // Deploy contract using create\n    assembly { pointer := create(0, add(code, 32), mload(code)) }\n\n    // Address MUST be non-zero\n    if (pointer == address(0)) revert WriteError();\n  }\n\n  /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @return data read from `_pointer` contract\n  */\n  function read(address _pointer) internal view returns (bytes memory) {\n    return Bytecode.codeAt(_pointer, 1, type(uint256).max);\n  }\n\n  /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @return data read from `_pointer` contract\n  */\n  function read(address _pointer, uint256 _start) internal view returns (bytes memory) {\n    return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\n  }\n\n  /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @param _end index before which to end extraction\n    @return data read from `_pointer` contract\n  */\n  function read(address _pointer, uint256 _start, uint256 _end) internal view returns (bytes memory) {\n    return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\n  }\n}\n"
    },
    "contracts/lib/Integers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * Integers Library updated from https://github.com/willitscale/solidity-util\n *\n * In summary this is a simple library of integer functions which allow a simple\n * conversion to and from strings\n *\n * @author Clement Walter <clement0walter@gmail.com>\n */\nlibrary Integers {\n    /**\n     * To String\n     *\n     * Converts an unsigned integer to the string equivalent value, returned as bytes\n     * Equivalent to javascript's toString(base)\n     *\n     * @param _number The unsigned integer to be converted to a string\n     * @param _base The base to convert the number to\n     * @param  _padding The target length of the string; result will be padded with 0 to reach this length while padding\n     *         of 0 means no padding\n     * @return bytes The resulting ASCII string value\n     */\n    function toString(\n        uint256 _number,\n        uint8 _base,\n        uint8 _padding\n    ) public pure returns (string memory) {\n        uint256 count = 0;\n        uint256 b = _number;\n        while (b != 0) {\n            count++;\n            b /= _base;\n        }\n        if (_number == 0) {\n            count++;\n        }\n        bytes memory res;\n        if (_padding == 0) {\n            res = new bytes(count);\n        } else {\n            res = new bytes(_padding);\n        }\n        for (uint256 i = 0; i < count; ++i) {\n            b = _number % _base;\n            if (b < 10) {\n                res[res.length - i - 1] = bytes1(uint8(b + 48)); // 0-9\n            } else {\n                res[res.length - i - 1] = bytes1(uint8((b % 10) + 65)); // A-F\n            }\n            _number /= _base;\n        }\n\n        for (uint256 i = count; i < _padding; ++i) {\n            res[res.length - i - 1] = hex\"30\"; // 0\n        }\n\n        return string(res);\n    }\n\n    function toString(uint256 _number) public pure returns (string memory) {\n        return toString(_number, 10, 0);\n    }\n\n    function toString(uint256 _number, uint8 _base)\n        public\n        pure\n        returns (string memory)\n    {\n        return toString(_number, _base, 0);\n    }\n\n    /**\n     * Load 16\n     *\n     * Converts two bytes to a 16 bit unsigned integer\n     *\n     * @param _leadingBytes the first byte of the unsigned integer in [256, 65536]\n     * @param _endingBytes the second byte of the unsigned integer in [0, 255]\n     * @return uint16 The resulting integer value\n     */\n    function load16(bytes1 _leadingBytes, bytes1 _endingBytes)\n        public\n        pure\n        returns (uint16)\n    {\n        return\n            (uint16(uint8(_leadingBytes)) << 8) + uint16(uint8(_endingBytes));\n    }\n\n    /**\n     * Load 12\n     *\n     * Converts three bytes into two uint12 integers\n     *\n     * @return (uint16, uint16) The two uint16 values up to 2^12 each\n     */\n    function load12x2(\n        bytes1 first,\n        bytes1 second,\n        bytes1 third\n    ) public pure returns (uint16, uint16) {\n        return (\n            (uint16(uint8(first)) << 4) + (uint16(uint8(second)) >> 4),\n            (uint16(uint8(second & hex\"0f\")) << 8) + uint16(uint8(third))\n        );\n    }\n}\n"
    },
    "contracts/dreamers/ChainRunnersConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IChainRunnersBaseRenderer.sol\";\n\n/*  @title Chain Runners constants\n    @author Clement Walter\n    @notice This contracts is used to retrieve constants used by the Chain Runners that are not exposed\n            by the Chain Runners contracts.\n*/\ncontract ChainRunnersConstants {\n    uint16[][13][3] public WEIGHTS;\n    uint8 public constant NUM_LAYERS = 13;\n    uint16 public constant NUM_RUNNERS = 10_000;\n    IChainRunnersBaseRenderer chainRunnersBaseRenderer;\n\n    constructor(address _rendererAddress) {\n        chainRunnersBaseRenderer = IChainRunnersBaseRenderer(_rendererAddress);\n\n        WEIGHTS[0][0] = [\n            36,\n            225,\n            225,\n            225,\n            360,\n            135,\n            27,\n            360,\n            315,\n            315,\n            315,\n            315,\n            225,\n            180,\n            225,\n            180,\n            360,\n            180,\n            45,\n            360,\n            360,\n            360,\n            27,\n            36,\n            360,\n            45,\n            180,\n            360,\n            225,\n            360,\n            225,\n            225,\n            360,\n            180,\n            45,\n            360,\n            18,\n            225,\n            225,\n            225,\n            225,\n            180,\n            225,\n            361\n        ];\n        WEIGHTS[0][1] = [\n            875,\n            1269,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            17,\n            8,\n            41\n        ];\n        WEIGHTS[0][2] = [\n            303,\n            303,\n            303,\n            303,\n            151,\n            30,\n            0,\n            0,\n            151,\n            151,\n            151,\n            151,\n            30,\n            303,\n            151,\n            30,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            30,\n            151,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            3066\n        ];\n        WEIGHTS[0][3] = [\n            645,\n            0,\n            1290,\n            322,\n            645,\n            645,\n            645,\n            967,\n            322,\n            967,\n            645,\n            967,\n            967,\n            973\n        ];\n        WEIGHTS[0][4] = [\n            0,\n            0,\n            0,\n            1250,\n            1250,\n            1250,\n            1250,\n            1250,\n            1250,\n            1250,\n            1250\n        ];\n        WEIGHTS[0][5] = [\n            121,\n            121,\n            121,\n            121,\n            121,\n            121,\n            243,\n            0,\n            0,\n            0,\n            0,\n            121,\n            121,\n            243,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            243,\n            0,\n            0,\n            0,\n            121,\n            121,\n            243,\n            121,\n            121,\n            306\n        ];\n        WEIGHTS[0][6] = [\n            925,\n            555,\n            185,\n            555,\n            925,\n            925,\n            185,\n            1296,\n            1296,\n            1296,\n            1857\n        ];\n        WEIGHTS[0][7] = [88, 88, 88, 88, 88, 265, 442, 8853];\n        WEIGHTS[0][8] = [189, 189, 47, 18, 9, 28, 37, 9483];\n        WEIGHTS[0][9] = [\n            340,\n            340,\n            340,\n            340,\n            340,\n            340,\n            34,\n            340,\n            340,\n            340,\n            340,\n            170,\n            170,\n            170,\n            102,\n            238,\n            238,\n            238,\n            272,\n            340,\n            340,\n            340,\n            272,\n            238,\n            238,\n            238,\n            238,\n            170,\n            34,\n            340,\n            340,\n            136,\n            340,\n            340,\n            340,\n            340,\n            344\n        ];\n        WEIGHTS[0][10] = [\n            159,\n            212,\n            106,\n            53,\n            26,\n            159,\n            53,\n            265,\n            53,\n            212,\n            159,\n            265,\n            53,\n            265,\n            265,\n            212,\n            53,\n            159,\n            239,\n            53,\n            106,\n            5,\n            106,\n            53,\n            212,\n            212,\n            106,\n            159,\n            212,\n            265,\n            212,\n            265,\n            5066\n        ];\n        WEIGHTS[0][11] = [\n            139,\n            278,\n            278,\n            250,\n            250,\n            194,\n            222,\n            278,\n            278,\n            194,\n            222,\n            83,\n            222,\n            278,\n            139,\n            139,\n            27,\n            278,\n            278,\n            278,\n            278,\n            27,\n            278,\n            139,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            27,\n            139,\n            139,\n            139,\n            139,\n            0,\n            278,\n            194,\n            83,\n            83,\n            278,\n            83,\n            27,\n            306\n        ];\n        WEIGHTS[0][12] = [981, 2945, 654, 16, 981, 327, 654, 163, 3279];\n\n        // Skull\n        WEIGHTS[1][0] = [\n            36,\n            225,\n            225,\n            225,\n            360,\n            135,\n            27,\n            360,\n            315,\n            315,\n            315,\n            315,\n            225,\n            180,\n            225,\n            180,\n            360,\n            180,\n            45,\n            360,\n            360,\n            360,\n            27,\n            36,\n            360,\n            45,\n            180,\n            360,\n            225,\n            360,\n            225,\n            225,\n            360,\n            180,\n            45,\n            360,\n            18,\n            225,\n            225,\n            225,\n            225,\n            180,\n            225,\n            361\n        ];\n        WEIGHTS[1][1] = [\n            875,\n            1269,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            17,\n            8,\n            41\n        ];\n        WEIGHTS[1][2] = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            10000\n        ];\n        WEIGHTS[1][3] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        WEIGHTS[1][4] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        WEIGHTS[1][5] = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            384,\n            7692,\n            1923,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1\n        ];\n        WEIGHTS[1][6] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10000];\n        WEIGHTS[1][7] = [0, 0, 0, 0, 0, 909, 0, 9091];\n        WEIGHTS[1][8] = [0, 0, 0, 0, 0, 0, 0, 10000];\n        WEIGHTS[1][9] = [\n            526,\n            526,\n            526,\n            0,\n            0,\n            0,\n            0,\n            0,\n            526,\n            0,\n            0,\n            0,\n            526,\n            0,\n            526,\n            0,\n            0,\n            0,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            0,\n            0,\n            526,\n            0,\n            0,\n            0,\n            0,\n            532\n        ];\n        WEIGHTS[1][10] = [\n            80,\n            0,\n            400,\n            240,\n            80,\n            0,\n            240,\n            0,\n            0,\n            80,\n            80,\n            80,\n            0,\n            0,\n            0,\n            0,\n            80,\n            80,\n            0,\n            0,\n            80,\n            80,\n            0,\n            80,\n            80,\n            80,\n            80,\n            80,\n            0,\n            0,\n            0,\n            0,\n            8000\n        ];\n        WEIGHTS[1][11] = [\n            289,\n            0,\n            0,\n            0,\n            0,\n            404,\n            462,\n            578,\n            578,\n            0,\n            462,\n            173,\n            462,\n            578,\n            0,\n            0,\n            57,\n            0,\n            57,\n            0,\n            57,\n            57,\n            578,\n            289,\n            578,\n            57,\n            0,\n            57,\n            57,\n            57,\n            578,\n            578,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            57,\n            289,\n            578,\n            0,\n            0,\n            0,\n            231,\n            57,\n            0,\n            0,\n            1745\n        ];\n        WEIGHTS[1][12] = [714, 714, 714, 0, 714, 0, 0, 0, 7144];\n\n        // Bot\n        WEIGHTS[2][0] = [\n            36,\n            225,\n            225,\n            225,\n            360,\n            135,\n            27,\n            360,\n            315,\n            315,\n            315,\n            315,\n            225,\n            180,\n            225,\n            180,\n            360,\n            180,\n            45,\n            360,\n            360,\n            360,\n            27,\n            36,\n            360,\n            45,\n            180,\n            360,\n            225,\n            360,\n            225,\n            225,\n            360,\n            180,\n            45,\n            360,\n            18,\n            225,\n            225,\n            225,\n            225,\n            180,\n            225,\n            361\n        ];\n        WEIGHTS[2][1] = [\n            875,\n            1269,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            17,\n            8,\n            41\n        ];\n        WEIGHTS[2][2] = [\n            303,\n            303,\n            303,\n            303,\n            151,\n            30,\n            0,\n            0,\n            151,\n            151,\n            151,\n            151,\n            30,\n            303,\n            151,\n            30,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            30,\n            151,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            3066\n        ];\n        WEIGHTS[2][3] = [\n            645,\n            0,\n            1290,\n            322,\n            645,\n            645,\n            645,\n            967,\n            322,\n            967,\n            645,\n            967,\n            967,\n            973\n        ];\n        WEIGHTS[2][4] = [2500, 2500, 2500, 0, 0, 0, 0, 0, 0, 2500, 0];\n        WEIGHTS[2][5] = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            588,\n            588,\n            588,\n            588,\n            588,\n            0,\n            0,\n            588,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            588,\n            588,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            4\n        ];\n        WEIGHTS[2][6] = [\n            925,\n            555,\n            185,\n            555,\n            925,\n            925,\n            185,\n            1296,\n            1296,\n            1296,\n            1857\n        ];\n        WEIGHTS[2][7] = [88, 88, 88, 88, 88, 265, 442, 8853];\n        WEIGHTS[2][8] = [183, 274, 274, 18, 18, 27, 36, 9170];\n        WEIGHTS[2][9] = [\n            340,\n            340,\n            340,\n            340,\n            340,\n            340,\n            34,\n            340,\n            340,\n            340,\n            340,\n            170,\n            170,\n            170,\n            102,\n            238,\n            238,\n            238,\n            272,\n            340,\n            340,\n            340,\n            272,\n            238,\n            238,\n            238,\n            238,\n            170,\n            34,\n            340,\n            340,\n            136,\n            340,\n            340,\n            340,\n            340,\n            344\n        ];\n        WEIGHTS[2][10] = [\n            217,\n            362,\n            217,\n            144,\n            72,\n            289,\n            144,\n            362,\n            72,\n            289,\n            217,\n            362,\n            72,\n            362,\n            362,\n            289,\n            0,\n            217,\n            0,\n            72,\n            144,\n            7,\n            217,\n            72,\n            217,\n            217,\n            289,\n            217,\n            289,\n            362,\n            217,\n            362,\n            3269\n        ];\n        WEIGHTS[2][11] = [\n            139,\n            278,\n            278,\n            250,\n            250,\n            194,\n            222,\n            278,\n            278,\n            194,\n            222,\n            83,\n            222,\n            278,\n            139,\n            139,\n            27,\n            278,\n            278,\n            278,\n            278,\n            27,\n            278,\n            139,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            27,\n            139,\n            139,\n            139,\n            139,\n            0,\n            278,\n            194,\n            83,\n            83,\n            278,\n            83,\n            27,\n            306\n        ];\n        WEIGHTS[2][12] = [981, 2945, 654, 16, 981, 327, 654, 163, 3279];\n    }\n\n    function splitNumber(uint256 _number)\n        public\n        pure\n        returns (uint16[NUM_LAYERS] memory numbers)\n    {\n        for (uint256 i = 0; i < numbers.length; i++) {\n            numbers[i] = uint16(_number % NUM_RUNNERS);\n            _number >>= 14;\n        }\n        return numbers;\n    }\n}\n"
    },
    "@0xsequence/sstore2/contracts/utils/Bytecode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\nlibrary Bytecode {\n  error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\n\n  /**\n    @notice Generate a creation code that results on a contract with `_code` as bytecode\n    @param _code The returning value of the resulting `creationCode`\n    @return creationCode (constructor) for new contract\n  */\n  function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {\n    /*\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\n      0x01    0x80         0x80        DUP1                size size\n      0x02    0x60         0x600e      PUSH1 14            14 size size\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\n      0x04    0x39         0x39        CODECOPY            size\n      0x05    0x60         0x6000      PUSH1 00            0 size\n      0x06    0xf3         0xf3        RETURN\n      <CODE>\n    */\n\n    return abi.encodePacked(\n      hex\"63\",\n      uint32(_code.length),\n      hex\"80_60_0E_60_00_39_60_00_F3\",\n      _code\n    );\n  }\n\n  /**\n    @notice Returns the size of the code on a given address\n    @param _addr Address that may or may not contain code\n    @return size of the code on the given `_addr`\n  */\n  function codeSize(address _addr) internal view returns (uint256 size) {\n    assembly { size := extcodesize(_addr) }\n  }\n\n  /**\n    @notice Returns the code of a given address\n    @dev It will fail if `_end < _start`\n    @param _addr Address that may or may not contain code\n    @param _start number of bytes of code to skip on read\n    @param _end index before which to end extraction\n    @return oCode read from `_addr` deployed bytecode\n\n    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\n  */\n  function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {\n    uint256 csize = codeSize(_addr);\n    if (csize == 0) return bytes(\"\");\n\n    if (_start > csize) return bytes(\"\");\n    if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); \n\n    unchecked {\n      uint256 reqSize = _end - _start;\n      uint256 maxSize = csize - _start;\n\n      uint256 size = maxSize < reqSize ? maxSize : reqSize;\n\n      assembly {\n        // allocate output byte array - this could also be done without assembly\n        // by using o_code = new bytes(size)\n        oCode := mload(0x40)\n        // new \"memory end\" including padding\n        mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n        // store length in memory\n        mstore(oCode, size)\n        // actually retrieve the code, this needs assembly\n        extcodecopy(_addr, add(oCode, 0x20), _start, size)\n      }\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IChainRunnersBaseRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IChainRunnersBaseRenderer {\n    function getRaceIndex(uint16 _dna) external view returns (uint8);\n\n    function getLayerIndex(\n        uint16 _dna,\n        uint8 _index,\n        uint16 _raceIndex\n    ) external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "contracts/runners/ChainRunners.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./ChainRunnersTypes.sol\";\nimport \"./IChainRunnersRenderer.sol\";\n\n/*\n               ::::                                                                                                                                                  :::#%=\n               @*==+-                                                                                                                                               ++==*=.\n               #+=#=++..                                                                                                                                        ..=*=*+-#:\n                :=+++++++=====================================:    .===============================================. .=========================================++++++++=\n                 .%-+%##+=--==================================+=..=+-=============================================-+*+======================================---+##+=#-.\n                   -+++@@%++++@@@%+++++++++++++++++++++++++++%#++++++%#+++#@@@#+++++++++@@%++++++++++++++++++++@#+.=+*@*+*@@@@*+++++++++++++++++++++++%@@@#+++#@@+++=\n                    -*-#%@@%%%=*%@%*++=++=+==+=++=++=+=++=++==#@%#%#+++=+=*@%*+=+==+=+++%*++==+=++=+==+=++=+=++@%%#%#++++*@%#++=++=++=++=+=++=++=+=+*%%*==*%@@@*:%=\n                     :@:+@@@@@@*+++%@@*+===========+*=========#@@========+#%==========*@========##*#*+=======*@##*======#@#+=======*#*============+#%++#@@%#@@#++=.\n                      .*+=%@%*%@%##++@@%#=-==-=--==*%=========*%==--=--=-====--=--=-=##=--=-=--%%%%%+=-=--=-=*%=--=--=-=#%=--=----=#%=--=-=--=-+%#+==#%@@*#%@=++.\n                        +%.#@@###%@@@@@%*---------#@%########@%*---------------------##---------------------##---------%%*--------@@#---------+#@=#@@#+==@@%*++-\n                        .:*+*%@#+=*%@@@*=-------=#%#=-------=%*---------=*#*--------#+=--------===--------=#%*-------=#%*-------==@%#--------=%@@%#*+=-+#%*+*:.\n       ====================%*.@@%#==+##%@*=----------------+@#+---------@@*-------=*@+---------@@*--------=@+--------+@=--------*@@+-------+#@@%#==---+#@.*%====================\n     :*=--==================-:=#@@%*===+*@%+=============%%%@=========*%@*========+@+=--=====+%@+==========@+========+@========*%@@+======%%%**+=---=%@#=:-====================-#-\n       +++**%@@@#*****************@#*=---=##%@@@@@@@@@@@@@#**@@@@****************%@@*+++@#***********#@************************************+=------=*@#*********************@#+=+:\n        .-##=*@@%*----------------+%@%=---===+%@@@@@@@*+++---%#++----------------=*@@*+++=-----------=+#=------------------------------------------+%+--------------------+#@-=@\n         :%:#%#####+=-=-*@@+--=-==-=*@=--=-==-=*@@#*=-==-=-+@===-==-=-=++==-=-==--=@%===-==----+-==-==--+*+-==-==---=*@@@@@@%#===-=-=+%@%-==-=-==-#@%=-==-==--+#@@@@@@@@@@@@*+++\n        =*=#@#=----==-=-=++=--=-==-=*@=--=-==-=*@@+-=-==-==+@===-=--=-*@@*=-=-==--+@=--=-==--+#@-==-==---+%-==-==---=+++#@@@#--==-=-=++++-=--=-===#%+=-==-==---=++++++++@@@%.#*\n        +#:@%*===================++%#=========%@%=========#%=========+#@%+=======#%==========*@#=========*%=========+*+%@@@+========+*==========+@@%+**+================*%#*=+=\n       *++#@*+=++++++*#%*+++++=+++*%%++++=++++%%*=+++++++##*=++++=++=%@@++++=++=+#%++++=++++#%@=+++++++=*#*+++++++=#%@@@@@*++=++++=#%@*+++=++=+++@#*****=+++++++=+++++*%@@+:=+=\n    :=*=#%#@@@@#%@@@%#@@#++++++++++%%*+++++++++++++++++**@*+++++++++*%#++++++++=*##++++++++*%@%+++++++++##+++++++++#%%%%%%++++**#@@@@@**+++++++++++++++++=*%@@@%#@@@@#%@@@%#@++*:.\n    #*:@#=-+%#+:=*@*=-+@%#++++++++#%@@#*++++++++++++++#%@#*++++++++*@@#+++++++++@#++++++++*@@#+++++++++##*+++++++++++++++++###@@@@++*@@#+++++++++++++++++++*@@#=:+#%+--+@*=-+%*.@=\n    ++=#%#+%@@%=#%@%#+%%#++++++*#@@@%###**************@@@++++++++**#@##*********#*********#@@#++++++***@#******%@%#*++**#@@@%##+==+++=*#**********%%*++++++++#%#=%@@%+*%@%*+%#*=*-\n     .-*+===========*@@+++++*%%%@@@++***************+.%%*++++#%%%@@%=:=******************--@@#+++*%%@#==+***--*@%*++*%@@*===+**=--   -************++@%%#++++++#@@@*==========*+-\n        =*******##.#%#++++*%@@@%+==+=             *#-%@%**%%###*====**-               -@:*@@##@###*==+**-.-#=+@@#*@##*==+***=                     =+=##%@*+++++*%@@#.#%******:\n               ++++%#+++*#@@@@+++==.              **-@@@%+++++++===-                 -+++#@@+++++++==:  :+++%@@+++++++==:                          .=++++@%##++++@@%++++\n             :%:*%%****%@@%+==*-                .%==*====**+...                      #*.#+==***....    #+=#%+==****:.                                ..-*=*%@%#++*#%@=+%.\n            -+++#%+#%@@@#++===                  .@*++===-                            #%++===           %#+++===                                          =+++%@%##**@@*.@:\n          .%-=%@##@@%*==++                                                                                                                                 .*==+#@@%*%@%=*=.\n         .+++#@@@@@*++==.                                                                                                                                    -==++#@@@@@@=+%\n       .=*=%@@%%%#=*=.                                                                                                                                          .*+=%@@@@%+-#.\n       @=-@@@%:++++.                                                                                                                                              -+++**@@#+*=:\n    .-+=*#%%++*::.                                                                                                                                                  :+**=#%@#==#\n    #*:@*+++=:                                                                                                                                                          =+++@*++=:\n  :*-=*=++..                                                                                                                                                             .=*=#*.%=\n +#.=+++:                                                                                                                                                                   ++++:+#\n*+=#-::                                                                                                                                                                      .::*+=*\n\n*/\n\ncontract ChainRunners is ERC721Enumerable, Ownable, ReentrancyGuard {\n    mapping(uint256 => ChainRunnersTypes.ChainRunner) runners;\n\n    address public renderingContractAddress;\n\n    event GenerateRunner(uint256 indexed tokenId, uint256 dna);\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n    Counters.Counter private _reservedTokenIds;\n\n    uint256 private constant MAX_RUNNERS = 10000;\n    uint256 private constant FOUNDERS_RESERVE_AMOUNT = 85;\n    uint256 private constant MAX_PUBLIC_RUNNERS =\n        MAX_RUNNERS - FOUNDERS_RESERVE_AMOUNT;\n    uint256 private constant MINT_PRICE = 0.05 ether;\n    uint256 private constant MAX_PER_ADDRESS = 10;\n\n    uint256 private constant MAX_PER_EARLY_ACCESS_ADDRESS = 5;\n\n    uint256 private runnerZeroHash;\n    uint256 private runnerZeroDNA;\n\n    uint256 public earlyAccessStartTimestamp;\n    uint256 public publicSaleStartTimestamp;\n\n    mapping(address => bool) public isOnEarlyAccessList;\n    mapping(address => uint256) public earlyAccessMintedCounts;\n    mapping(address => uint256) private founderMintCountsRemaining;\n\n    constructor() ERC721(\"Chain Runners\", \"RUN\") {}\n\n    modifier whenPublicSaleActive() {\n        require(isPublicSaleOpen(), \"Public sale not open\");\n        _;\n    }\n\n    modifier whenEarlyAccessActive() {\n        require(isEarlyAccessOpen(), \"Early access not open\");\n        _;\n    }\n\n    function setRenderingContractAddress(address _renderingContractAddress)\n        public\n        onlyOwner\n    {\n        renderingContractAddress = _renderingContractAddress;\n    }\n\n    function mintPublicSale(uint256 _count)\n        external\n        payable\n        nonReentrant\n        whenPublicSaleActive\n        returns (uint256, uint256)\n    {\n        require(\n            _count > 0 && _count <= MAX_PER_ADDRESS,\n            \"Invalid Runner count\"\n        );\n        require(\n            _tokenIds.current() + _count <= MAX_PUBLIC_RUNNERS,\n            \"All Runners have been minted\"\n        );\n        require(\n            _count * MINT_PRICE == msg.value,\n            \"Incorrect amount of ether sent\"\n        );\n\n        uint256 firstMintedId = _tokenIds.current() + 1;\n\n        for (uint256 i = 0; i < _count; i++) {\n            _tokenIds.increment();\n            mint(_tokenIds.current());\n        }\n\n        return (firstMintedId, _count);\n    }\n\n    function mintEarlyAccess(uint256 _count)\n        external\n        payable\n        nonReentrant\n        whenEarlyAccessActive\n        returns (uint256, uint256)\n    {\n        require(_count != 0, \"Invalid Runner count\");\n        require(\n            isOnEarlyAccessList[msg.sender],\n            \"Address not on Early Access list\"\n        );\n        require(\n            _tokenIds.current() + _count <= MAX_PUBLIC_RUNNERS,\n            \"All Runners have been minted\"\n        );\n        require(\n            _count * MINT_PRICE == msg.value,\n            \"Incorrect amount of ether sent\"\n        );\n\n        uint256 userMintedAmount = earlyAccessMintedCounts[msg.sender] + _count;\n        require(\n            userMintedAmount <= MAX_PER_EARLY_ACCESS_ADDRESS,\n            \"Max Early Access count per address exceeded\"\n        );\n\n        uint256 firstMintedId = _tokenIds.current() + 1;\n        for (uint256 i = 0; i < _count; i++) {\n            _tokenIds.increment();\n            mint(_tokenIds.current());\n        }\n        earlyAccessMintedCounts[msg.sender] = userMintedAmount;\n        return (firstMintedId, _count);\n    }\n\n    function allocateFounderMint(address _addr, uint256 _count)\n        public\n        onlyOwner\n        nonReentrant\n    {\n        founderMintCountsRemaining[_addr] = _count;\n    }\n\n    function founderMint(uint256 _count)\n        public\n        nonReentrant\n        returns (uint256, uint256)\n    {\n        require(\n            _count > 0 && _count <= MAX_PER_ADDRESS,\n            \"Invalid Runner count\"\n        );\n        require(\n            _reservedTokenIds.current() + _count <= FOUNDERS_RESERVE_AMOUNT,\n            \"All reserved Runners have been minted\"\n        );\n        require(\n            founderMintCountsRemaining[msg.sender] >= _count,\n            \"You cannot mint this many reserved Runners\"\n        );\n\n        uint256 firstMintedId = MAX_PUBLIC_RUNNERS + _tokenIds.current() + 1;\n        for (uint256 i = 0; i < _count; i++) {\n            _reservedTokenIds.increment();\n            mint(MAX_PUBLIC_RUNNERS + _reservedTokenIds.current());\n        }\n        founderMintCountsRemaining[msg.sender] -= _count;\n        return (firstMintedId, _count);\n    }\n\n    function mint(uint256 tokenId) public {\n        ChainRunnersTypes.ChainRunner memory runner;\n        runner.dna = uint256(\n            keccak256(\n                abi.encodePacked(\n                    tokenId,\n                    msg.sender,\n                    block.difficulty,\n                    block.timestamp\n                )\n            )\n        );\n\n        _safeMint(msg.sender, tokenId);\n        runners[tokenId] = runner;\n    }\n\n    function getRemainingEarlyAccessMints(address _addr)\n        public\n        view\n        returns (uint256)\n    {\n        if (!isOnEarlyAccessList[_addr]) {\n            return 0;\n        }\n        return MAX_PER_EARLY_ACCESS_ADDRESS - earlyAccessMintedCounts[_addr];\n    }\n\n    function getRemainingFounderMints(address _addr)\n        public\n        view\n        returns (uint256)\n    {\n        return founderMintCountsRemaining[_addr];\n    }\n\n    function isPublicSaleOpen() public view returns (bool) {\n        return\n            block.timestamp >= publicSaleStartTimestamp &&\n            publicSaleStartTimestamp != 0;\n    }\n\n    function isEarlyAccessOpen() public view returns (bool) {\n        return\n            !isPublicSaleOpen() &&\n            block.timestamp >= earlyAccessStartTimestamp &&\n            earlyAccessStartTimestamp != 0;\n    }\n\n    function addToEarlyAccessList(address[] memory toEarlyAccessList)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i < toEarlyAccessList.length; i++) {\n            isOnEarlyAccessList[toEarlyAccessList[i]] = true;\n        }\n    }\n\n    function removeFromEarlyAccessList(address[] memory toRemove)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i < toRemove.length; i++) {\n            isOnEarlyAccessList[toRemove[i]] = false;\n        }\n    }\n\n    function setPublicSaleTimestamp(uint256 timestamp) external onlyOwner {\n        publicSaleStartTimestamp = timestamp;\n    }\n\n    function setEarlyAccessTimestamp(uint256 timestamp) external onlyOwner {\n        earlyAccessStartTimestamp = timestamp;\n    }\n\n    function checkHash(string memory seed) public pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(seed)));\n    }\n\n    function configureRunnerZero(\n        uint256 _runnerZeroHash,\n        uint256 _runnerZeroDNA\n    ) external onlyOwner {\n        require(runnerZeroHash == 0, \"Runner Zero has already been configured\");\n        runnerZeroHash = _runnerZeroHash;\n        runnerZeroDNA = _runnerZeroDNA;\n    }\n\n    function mintRunnerZero(string memory seed) external {\n        require(runnerZeroHash != 0, \"Runner Zero has not been configured\");\n        require(!_exists(0), \"Runner Zero has already been minted\");\n        require(checkHash(seed) == runnerZeroHash, \"Incorrect seed\");\n\n        ChainRunnersTypes.ChainRunner memory runner;\n        runner.dna = runnerZeroDNA;\n\n        _safeMint(msg.sender, 0);\n        runners[0] = runner;\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(_tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        if (renderingContractAddress == address(0)) {\n            return \"\";\n        }\n\n        IChainRunnersRenderer renderer = IChainRunnersRenderer(\n            renderingContractAddress\n        );\n        return renderer.tokenURI(_tokenId, runners[_tokenId]);\n    }\n\n    function tokenURIForSeed(uint256 _tokenId, uint256 seed)\n        public\n        view\n        virtual\n        returns (string memory)\n    {\n        require(\n            _exists(_tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        if (renderingContractAddress == address(0)) {\n            return \"\";\n        }\n\n        ChainRunnersTypes.ChainRunner memory runner;\n        runner.dna = seed;\n\n        IChainRunnersRenderer renderer = IChainRunnersRenderer(\n            renderingContractAddress\n        );\n        return renderer.tokenURI(_tokenId, runner);\n    }\n\n    function getDna(uint256 _tokenId) public view returns (uint256) {\n        return runners[_tokenId].dna;\n    }\n\n    receive() external payable {}\n\n    function withdraw() public onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/runners/ChainRunnersTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ChainRunnersTypes {\n    struct ChainRunner {\n        uint256 dna;\n    }\n}\n"
    },
    "contracts/runners/IChainRunnersRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ChainRunnersTypes.sol\";\n\ninterface IChainRunnersRenderer {\n    function tokenURI(\n        uint256 tokenId,\n        ChainRunnersTypes.ChainRunner memory runnerData\n    ) external view returns (string memory);\n}\n"
    },
    "contracts/runners/ChainRunnersBaseRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./ChainRunnersTypes.sol\";\n\n/*\n               ::::                                                                                                                                                  :::#%=\n               @*==+-                                                                                                                                               ++==*=.\n               #+=#=++..                                                                                                                                        ..=*=*+-#:\n                :=+++++++=====================================:    .===============================================. .=========================================++++++++=\n                 .%-+%##+=--==================================+=..=+-=============================================-+*+======================================---+##+=#-.\n                   -+++@@%++++@@@%+++++++++++++++++++++++++++%#++++++%#+++#@@@#+++++++++@@%++++++++++++++++++++@#+.=+*@*+*@@@@*+++++++++++++++++++++++%@@@#+++#@@+++=\n                    -*-#%@@%%%=*%@%*++=++=+==+=++=++=+=++=++==#@%#%#+++=+=*@%*+=+==+=+++%*++==+=++=+==+=++=+=++@%%#%#++++*@%#++=++=++=++=+=++=++=+=+*%%*==*%@@@*:%=\n                     :@:+@@@@@@*+++%@@*+===========+*=========#@@========+#%==========*@========##*#*+=======*@##*======#@#+=======*#*============+#%++#@@%#@@#++=.\n                      .*+=%@%*%@%##++@@%#=-==-=--==*%=========*%==--=--=-====--=--=-=##=--=-=--%%%%%+=-=--=-=*%=--=--=-=#%=--=----=#%=--=-=--=-+%#+==#%@@*#%@=++.\n                        +%.#@@###%@@@@@%*---------#@%########@%*---------------------##---------------------##---------%%*--------@@#---------+#@=#@@#+==@@%*++-\n                        .:*+*%@#+=*%@@@*=-------=#%#=-------=%*---------=*#*--------#+=--------===--------=#%*-------=#%*-------==@%#--------=%@@%#*+=-+#%*+*:.\n       ====================%*.@@%#==+##%@*=----------------+@#+---------@@*-------=*@+---------@@*--------=@+--------+@=--------*@@+-------+#@@%#==---+#@.*%====================\n     :*=--==================-:=#@@%*===+*@%+=============%%%@=========*%@*========+@+=--=====+%@+==========@+========+@========*%@@+======%%%**+=---=%@#=:-====================-#-\n       +++**%@@@#*****************@#*=---=##%@@@@@@@@@@@@@#**@@@@****************%@@*+++@#***********#@************************************+=------=*@#*********************@#+=+:\n        .-##=*@@%*----------------+%@%=---===+%@@@@@@@*+++---%#++----------------=*@@*+++=-----------=+#=------------------------------------------+%+--------------------+#@-=@\n         :%:#%#####+=-=-*@@+--=-==-=*@=--=-==-=*@@#*=-==-=-+@===-==-=-=++==-=-==--=@%===-==----+-==-==--+*+-==-==---=*@@@@@@%#===-=-=+%@%-==-=-==-#@%=-==-==--+#@@@@@@@@@@@@*+++\n        =*=#@#=----==-=-=++=--=-==-=*@=--=-==-=*@@+-=-==-==+@===-=--=-*@@*=-=-==--+@=--=-==--+#@-==-==---+%-==-==---=+++#@@@#--==-=-=++++-=--=-===#%+=-==-==---=++++++++@@@%.#*\n        +#:@%*===================++%#=========%@%=========#%=========+#@%+=======#%==========*@#=========*%=========+*+%@@@+========+*==========+@@%+**+================*%#*=+=\n       *++#@*+=++++++*#%*+++++=+++*%%++++=++++%%*=+++++++##*=++++=++=%@@++++=++=+#%++++=++++#%@=+++++++=*#*+++++++=#%@@@@@*++=++++=#%@*+++=++=+++@#*****=+++++++=+++++*%@@+:=+=\n    :=*=#%#@@@@#%@@@%#@@#++++++++++%%*+++++++++++++++++**@*+++++++++*%#++++++++=*##++++++++*%@%+++++++++##+++++++++#%%%%%%++++**#@@@@@**+++++++++++++++++=*%@@@%#@@@@#%@@@%#@++*:.\n    #*:@#=-+%#+:=*@*=-+@%#++++++++#%@@#*++++++++++++++#%@#*++++++++*@@#+++++++++@#++++++++*@@#+++++++++##*+++++++++++++++++###@@@@++*@@#+++++++++++++++++++*@@#=:+#%+--+@*=-+%*.@=\n    ++=#%#+%@@%=#%@%#+%%#++++++*#@@@%###**************@@@++++++++**#@##*********#*********#@@#++++++***@#******%@%#*++**#@@@%##+==+++=*#**********%%*++++++++#%#=%@@%+*%@%*+%#*=*-\n     .-*+===========*@@+++++*%%%@@@++***************+.%%*++++#%%%@@%=:=******************--@@#+++*%%@#==+***--*@%*++*%@@*===+**=--   -************++@%%#++++++#@@@*==========*+-\n        =*******##.#%#++++*%@@@%+==+=             *#-%@%**%%###*====**-               -@:*@@##@###*==+**-.-#=+@@#*@##*==+***=                     =+=##%@*+++++*%@@#.#%******:\n               ++++%#+++*#@@@@+++==.              **-@@@%+++++++===-                 -+++#@@+++++++==:  :+++%@@+++++++==:                          .=++++@%##++++@@%++++\n             :%:*%%****%@@%+==*-                .%==*====**+...                      #*.#+==***....    #+=#%+==****:.                                ..-*=*%@%#++*#%@=+%.\n            -+++#%+#%@@@#++===                  .@*++===-                            #%++===           %#+++===                                          =+++%@%##**@@*.@:\n          .%-=%@##@@%*==++                                                                                                                                 .*==+#@@%*%@%=*=.\n         .+++#@@@@@*++==.                                                                                                                                    -==++#@@@@@@=+%\n       .=*=%@@%%%#=*=.                                                                                                                                          .*+=%@@@@%+-#.\n       @=-@@@%:++++.                                                                                                                                              -+++**@@#+*=:\n    .-+=*#%%++*::.                                                                                                                                                  :+**=#%@#==#\n    #*:@*+++=:                                                                                                                                                          =+++@*++=:\n  :*-=*=++..                                                                                                                                                             .=*=#*.%=\n +#.=+++:                                                                                                                                                                   ++++:+#\n*+=#-::                                                                                                                                                                      .::*+=*\n\n*/\n\ncontract ChainRunnersBaseRenderer is Ownable, ReentrancyGuard {\n    struct SVGCursor {\n        uint8 x;\n        uint8 y;\n        string color1;\n        string color2;\n        string color3;\n        string color4;\n    }\n\n    struct Buffer {\n        string one;\n        string two;\n        string three;\n        string four;\n        string five;\n        string six;\n        string seven;\n        string eight;\n    }\n\n    struct Color {\n        string hexString;\n        uint256 alpha;\n        uint256 red;\n        uint256 green;\n        uint256 blue;\n    }\n\n    struct Layer {\n        string name;\n        bytes hexString;\n    }\n\n    struct LayerInput {\n        string name;\n        bytes hexString;\n        uint8 layerIndex;\n        uint8 itemIndex;\n    }\n\n    uint256 public constant NUM_LAYERS = 13;\n    uint256 public constant NUM_COLORS = 8;\n\n    mapping(uint256 => Layer)[NUM_LAYERS] layers;\n\n    /*\n    This indexes into a race, then a layer index, then an array capturing the frequency each layer should be selected.\n    Shout out to Anonymice for the rarity impl inspiration.\n    */\n    uint16[][NUM_LAYERS][3] WEIGHTS;\n\n    constructor() {\n        // Default\n        WEIGHTS[0][0] = [\n            36,\n            225,\n            225,\n            225,\n            360,\n            135,\n            27,\n            360,\n            315,\n            315,\n            315,\n            315,\n            225,\n            180,\n            225,\n            180,\n            360,\n            180,\n            45,\n            360,\n            360,\n            360,\n            27,\n            36,\n            360,\n            45,\n            180,\n            360,\n            225,\n            360,\n            225,\n            225,\n            360,\n            180,\n            45,\n            360,\n            18,\n            225,\n            225,\n            225,\n            225,\n            180,\n            225,\n            361\n        ];\n        WEIGHTS[0][1] = [\n            875,\n            1269,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            17,\n            8,\n            41\n        ];\n        WEIGHTS[0][2] = [\n            303,\n            303,\n            303,\n            303,\n            151,\n            30,\n            0,\n            0,\n            151,\n            151,\n            151,\n            151,\n            30,\n            303,\n            151,\n            30,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            30,\n            151,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            3066\n        ];\n        WEIGHTS[0][3] = [\n            645,\n            0,\n            1290,\n            322,\n            645,\n            645,\n            645,\n            967,\n            322,\n            967,\n            645,\n            967,\n            967,\n            973\n        ];\n        WEIGHTS[0][4] = [\n            0,\n            0,\n            0,\n            1250,\n            1250,\n            1250,\n            1250,\n            1250,\n            1250,\n            1250,\n            1250\n        ];\n        WEIGHTS[0][5] = [\n            121,\n            121,\n            121,\n            121,\n            121,\n            121,\n            243,\n            0,\n            0,\n            0,\n            0,\n            121,\n            121,\n            243,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            121,\n            121,\n            243,\n            121,\n            121,\n            243,\n            0,\n            0,\n            0,\n            121,\n            121,\n            243,\n            121,\n            121,\n            306\n        ];\n        WEIGHTS[0][6] = [\n            925,\n            555,\n            185,\n            555,\n            925,\n            925,\n            185,\n            1296,\n            1296,\n            1296,\n            1857\n        ];\n        WEIGHTS[0][7] = [88, 88, 88, 88, 88, 265, 442, 8853];\n        WEIGHTS[0][8] = [189, 189, 47, 18, 9, 28, 37, 9483];\n        WEIGHTS[0][9] = [\n            340,\n            340,\n            340,\n            340,\n            340,\n            340,\n            34,\n            340,\n            340,\n            340,\n            340,\n            170,\n            170,\n            170,\n            102,\n            238,\n            238,\n            238,\n            272,\n            340,\n            340,\n            340,\n            272,\n            238,\n            238,\n            238,\n            238,\n            170,\n            34,\n            340,\n            340,\n            136,\n            340,\n            340,\n            340,\n            340,\n            344\n        ];\n        WEIGHTS[0][10] = [\n            159,\n            212,\n            106,\n            53,\n            26,\n            159,\n            53,\n            265,\n            53,\n            212,\n            159,\n            265,\n            53,\n            265,\n            265,\n            212,\n            53,\n            159,\n            239,\n            53,\n            106,\n            5,\n            106,\n            53,\n            212,\n            212,\n            106,\n            159,\n            212,\n            265,\n            212,\n            265,\n            5066\n        ];\n        WEIGHTS[0][11] = [\n            139,\n            278,\n            278,\n            250,\n            250,\n            194,\n            222,\n            278,\n            278,\n            194,\n            222,\n            83,\n            222,\n            278,\n            139,\n            139,\n            27,\n            278,\n            278,\n            278,\n            278,\n            27,\n            278,\n            139,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            27,\n            139,\n            139,\n            139,\n            139,\n            0,\n            278,\n            194,\n            83,\n            83,\n            278,\n            83,\n            27,\n            306\n        ];\n        WEIGHTS[0][12] = [981, 2945, 654, 16, 981, 327, 654, 163, 3279];\n\n        // Skull\n        WEIGHTS[1][0] = [\n            36,\n            225,\n            225,\n            225,\n            360,\n            135,\n            27,\n            360,\n            315,\n            315,\n            315,\n            315,\n            225,\n            180,\n            225,\n            180,\n            360,\n            180,\n            45,\n            360,\n            360,\n            360,\n            27,\n            36,\n            360,\n            45,\n            180,\n            360,\n            225,\n            360,\n            225,\n            225,\n            360,\n            180,\n            45,\n            360,\n            18,\n            225,\n            225,\n            225,\n            225,\n            180,\n            225,\n            361\n        ];\n        WEIGHTS[1][1] = [\n            875,\n            1269,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            17,\n            8,\n            41\n        ];\n        WEIGHTS[1][2] = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            10000\n        ];\n        WEIGHTS[1][3] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        WEIGHTS[1][4] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        WEIGHTS[1][5] = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            384,\n            7692,\n            1923,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1\n        ];\n        WEIGHTS[1][6] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10000];\n        WEIGHTS[1][7] = [0, 0, 0, 0, 0, 909, 0, 9091];\n        WEIGHTS[1][8] = [0, 0, 0, 0, 0, 0, 0, 10000];\n        WEIGHTS[1][9] = [\n            526,\n            526,\n            526,\n            0,\n            0,\n            0,\n            0,\n            0,\n            526,\n            0,\n            0,\n            0,\n            526,\n            0,\n            526,\n            0,\n            0,\n            0,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            526,\n            0,\n            0,\n            526,\n            0,\n            0,\n            0,\n            0,\n            532\n        ];\n        WEIGHTS[1][10] = [\n            80,\n            0,\n            400,\n            240,\n            80,\n            0,\n            240,\n            0,\n            0,\n            80,\n            80,\n            80,\n            0,\n            0,\n            0,\n            0,\n            80,\n            80,\n            0,\n            0,\n            80,\n            80,\n            0,\n            80,\n            80,\n            80,\n            80,\n            80,\n            0,\n            0,\n            0,\n            0,\n            8000\n        ];\n        WEIGHTS[1][11] = [\n            289,\n            0,\n            0,\n            0,\n            0,\n            404,\n            462,\n            578,\n            578,\n            0,\n            462,\n            173,\n            462,\n            578,\n            0,\n            0,\n            57,\n            0,\n            57,\n            0,\n            57,\n            57,\n            578,\n            289,\n            578,\n            57,\n            0,\n            57,\n            57,\n            57,\n            578,\n            578,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            57,\n            289,\n            578,\n            0,\n            0,\n            0,\n            231,\n            57,\n            0,\n            0,\n            1745\n        ];\n        WEIGHTS[1][12] = [714, 714, 714, 0, 714, 0, 0, 0, 7144];\n\n        // Bot\n        WEIGHTS[2][0] = [\n            36,\n            225,\n            225,\n            225,\n            360,\n            135,\n            27,\n            360,\n            315,\n            315,\n            315,\n            315,\n            225,\n            180,\n            225,\n            180,\n            360,\n            180,\n            45,\n            360,\n            360,\n            360,\n            27,\n            36,\n            360,\n            45,\n            180,\n            360,\n            225,\n            360,\n            225,\n            225,\n            360,\n            180,\n            45,\n            360,\n            18,\n            225,\n            225,\n            225,\n            225,\n            180,\n            225,\n            361\n        ];\n        WEIGHTS[2][1] = [\n            875,\n            1269,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            779,\n            17,\n            8,\n            41\n        ];\n        WEIGHTS[2][2] = [\n            303,\n            303,\n            303,\n            303,\n            151,\n            30,\n            0,\n            0,\n            151,\n            151,\n            151,\n            151,\n            30,\n            303,\n            151,\n            30,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            30,\n            151,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            303,\n            3066\n        ];\n        WEIGHTS[2][3] = [\n            645,\n            0,\n            1290,\n            322,\n            645,\n            645,\n            645,\n            967,\n            322,\n            967,\n            645,\n            967,\n            967,\n            973\n        ];\n        WEIGHTS[2][4] = [2500, 2500, 2500, 0, 0, 0, 0, 0, 0, 2500, 0];\n        WEIGHTS[2][5] = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            588,\n            588,\n            588,\n            588,\n            588,\n            0,\n            0,\n            588,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            588,\n            588,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            588,\n            0,\n            0,\n            4\n        ];\n        WEIGHTS[2][6] = [\n            925,\n            555,\n            185,\n            555,\n            925,\n            925,\n            185,\n            1296,\n            1296,\n            1296,\n            1857\n        ];\n        WEIGHTS[2][7] = [88, 88, 88, 88, 88, 265, 442, 8853];\n        WEIGHTS[2][8] = [183, 274, 274, 18, 18, 27, 36, 9170];\n        WEIGHTS[2][9] = [\n            340,\n            340,\n            340,\n            340,\n            340,\n            340,\n            34,\n            340,\n            340,\n            340,\n            340,\n            170,\n            170,\n            170,\n            102,\n            238,\n            238,\n            238,\n            272,\n            340,\n            340,\n            340,\n            272,\n            238,\n            238,\n            238,\n            238,\n            170,\n            34,\n            340,\n            340,\n            136,\n            340,\n            340,\n            340,\n            340,\n            344\n        ];\n        WEIGHTS[2][10] = [\n            217,\n            362,\n            217,\n            144,\n            72,\n            289,\n            144,\n            362,\n            72,\n            289,\n            217,\n            362,\n            72,\n            362,\n            362,\n            289,\n            0,\n            217,\n            0,\n            72,\n            144,\n            7,\n            217,\n            72,\n            217,\n            217,\n            289,\n            217,\n            289,\n            362,\n            217,\n            362,\n            3269\n        ];\n        WEIGHTS[2][11] = [\n            139,\n            278,\n            278,\n            250,\n            250,\n            194,\n            222,\n            278,\n            278,\n            194,\n            222,\n            83,\n            222,\n            278,\n            139,\n            139,\n            27,\n            278,\n            278,\n            278,\n            278,\n            27,\n            278,\n            139,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            278,\n            27,\n            139,\n            139,\n            139,\n            139,\n            0,\n            278,\n            194,\n            83,\n            83,\n            278,\n            83,\n            27,\n            306\n        ];\n        WEIGHTS[2][12] = [981, 2945, 654, 16, 981, 327, 654, 163, 3279];\n    }\n\n    function setLayers(LayerInput[] calldata toSet) external virtual onlyOwner {\n        for (uint16 i = 0; i < toSet.length; i++) {\n            layers[toSet[i].layerIndex][toSet[i].itemIndex] = Layer(\n                toSet[i].name,\n                toSet[i].hexString\n            );\n        }\n    }\n\n    function getLayer(uint8 layerIndex, uint8 itemIndex)\n        public\n        view\n        virtual\n        returns (Layer memory)\n    {\n        return layers[layerIndex][itemIndex];\n    }\n\n    /*\n    Get race index.  Race index represents the \"type\" of base character:\n\n    0 - Default, representing human and alien characters\n    1 - Skull\n    2 - Bot\n\n    This allows skull/bot characters to have distinct trait distributions.\n    */\n    function getRaceIndex(uint16 _dna) public view returns (uint8) {\n        uint16 lowerBound;\n        uint16 percentage;\n        for (uint8 i; i < WEIGHTS[0][1].length; i++) {\n            percentage = WEIGHTS[0][1][i];\n            if (_dna >= lowerBound && _dna < lowerBound + percentage) {\n                if (i == 1) {\n                    // Bot\n                    return 2;\n                } else if (i > 11) {\n                    // Skull\n                    return 1;\n                } else {\n                    // Default\n                    return 0;\n                }\n            }\n            lowerBound += percentage;\n        }\n        revert();\n    }\n\n    function getLayerIndex(\n        uint16 _dna,\n        uint8 _index,\n        uint16 _raceIndex\n    ) public view returns (uint8) {\n        uint16 lowerBound;\n        uint16 percentage;\n        for (uint8 i; i < WEIGHTS[_raceIndex][_index].length; i++) {\n            percentage = WEIGHTS[_raceIndex][_index][i];\n            if (_dna >= lowerBound && _dna < lowerBound + percentage) {\n                return i;\n            }\n            lowerBound += percentage;\n        }\n        // If not found, return index higher than available layers.  Will get filtered out.\n        return uint8(WEIGHTS[_raceIndex][_index].length);\n    }\n\n    /*\n    Generate base64 encoded tokenURI.\n\n    All string constants are pre-base64 encoded to save gas.\n    Input strings are padded with spacing/etc to ensure their length is a multiple of 3.\n    This way the resulting base64 encoded string is a multiple of 4 and will not include any '=' padding characters,\n    which allows these base64 string snippets to be concatenated with other snippets.\n    */\n    function tokenURI(\n        uint256 tokenId,\n        ChainRunnersTypes.ChainRunner memory runnerData\n    ) public view returns (string memory) {\n        (\n            Layer[NUM_LAYERS] memory tokenLayers,\n            Color[NUM_COLORS][NUM_LAYERS] memory tokenPalettes,\n            uint8 numTokenLayers,\n            string[NUM_LAYERS] memory traitTypes\n        ) = getTokenData(runnerData.dna);\n        string memory attributes;\n        for (uint8 i = 0; i < numTokenLayers; i++) {\n            attributes = string(\n                abi.encodePacked(\n                    attributes,\n                    bytes(attributes).length == 0 ? \"eyAg\" : \"LCB7\",\n                    \"InRyYWl0X3R5cGUiOiAi\",\n                    traitTypes[i],\n                    \"IiwidmFsdWUiOiAi\",\n                    tokenLayers[i].name,\n                    \"IiB9\"\n                )\n            );\n        }\n        string[4] memory svgBuffers = tokenSVGBuffer(\n            tokenLayers,\n            tokenPalettes,\n            numTokenLayers\n        );\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,eyAgImltYWdlX2RhdGEiOiAiPHN2ZyB2ZXJzaW9uPScxLjEnIHZpZXdCb3g9JzAgMCAzMjAgMzIwJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHNoYXBlLXJlbmRlcmluZz0nY3Jpc3BFZGdlcyc+\",\n                    svgBuffers[0],\n                    svgBuffers[1],\n                    svgBuffers[2],\n                    svgBuffers[3],\n                    \"PHN0eWxlPnJlY3R7d2lkdGg6MTBweDtoZWlnaHQ6MTBweDt9PC9zdHlsZT48L3N2Zz4gIiwgImF0dHJpYnV0ZXMiOiBb\",\n                    attributes,\n                    \"XSwgICAibmFtZSI6IlJ1bm5lciAj\",\n                    Base64.encode(uintToByteString(tokenId, 6)),\n                    \"IiwgImRlc2NyaXB0aW9uIjogIkNoYWluIFJ1bm5lcnMgYXJlIE1lZ2EgQ2l0eSByZW5lZ2FkZXMgMTAwJSBnZW5lcmF0ZWQgb24gY2hhaW4uIn0g\"\n                )\n            );\n    }\n\n    function tokenSVG(uint256 _dna) public view returns (string memory) {\n        (\n            Layer[NUM_LAYERS] memory tokenLayers,\n            Color[NUM_COLORS][NUM_LAYERS] memory tokenPalettes,\n            uint8 numTokenLayers,\n\n        ) = getTokenData(_dna);\n        string[4] memory buffer256 = tokenSVGBuffer(\n            tokenLayers,\n            tokenPalettes,\n            numTokenLayers\n        );\n        return\n            string(\n                abi.encodePacked(\n                    \"PHN2ZyB2ZXJzaW9uPScxLjEnIHZpZXdCb3g9JzAgMCAzMiAzMicgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBzaGFwZS1yZW5kZXJpbmc9J2NyaXNwRWRnZXMnIGhlaWdodD0nMTAwJScgd2lkdGg9JzEwMCUnICA+\",\n                    buffer256[0],\n                    buffer256[1],\n                    buffer256[2],\n                    buffer256[3],\n                    \"PHN0eWxlPnJlY3R7d2lkdGg6MXB4O2hlaWdodDoxcHg7fTwvc3R5bGU+PC9zdmc+\"\n                )\n            );\n    }\n\n    function getTokenData(uint256 _dna)\n        public\n        view\n        returns (\n            Layer[NUM_LAYERS] memory tokenLayers,\n            Color[NUM_COLORS][NUM_LAYERS] memory tokenPalettes,\n            uint8 numTokenLayers,\n            string[NUM_LAYERS] memory traitTypes\n        )\n    {\n        uint16[NUM_LAYERS] memory dna = splitNumber(_dna);\n        uint16 raceIndex = getRaceIndex(dna[1]);\n\n        bool hasFaceAcc = dna[7] < (10000 - WEIGHTS[raceIndex][7][7]);\n        bool hasMask = dna[8] < (10000 - WEIGHTS[raceIndex][8][7]);\n        bool hasHeadBelow = dna[9] < (10000 - WEIGHTS[raceIndex][9][36]);\n        bool hasHeadAbove = dna[11] < (10000 - WEIGHTS[raceIndex][11][48]);\n        bool useHeadAbove = (dna[0] % 2) > 0;\n        for (uint8 i = 0; i < NUM_LAYERS; i++) {\n            Layer memory layer = getLayer(\n                i,\n                getLayerIndex(dna[i], i, raceIndex)\n            );\n            if (layer.hexString.length > 0) {\n                /*\n                These conditions help make sure layer selection meshes well visually.\n                1. If mask, no face/eye acc/mouth acc\n                2. If face acc, no mask/mouth acc/face\n                3. If both head above & head below, randomly choose one\n                */\n                if (\n                    ((i == 2 || i == 12) && !hasMask && !hasFaceAcc) ||\n                    (i == 7 && !hasMask) ||\n                    (i == 10 && !hasMask) ||\n                    (i < 2 || (i > 2 && i < 7) || i == 8 || i == 9 || i == 11)\n                ) {\n                    if (\n                        (hasHeadBelow &&\n                            hasHeadAbove &&\n                            (i == 9 && useHeadAbove)) ||\n                        (i == 11 && !useHeadAbove)\n                    ) continue;\n                    tokenLayers[numTokenLayers] = layer;\n                    tokenPalettes[numTokenLayers] = palette(\n                        tokenLayers[numTokenLayers].hexString\n                    );\n                    traitTypes[numTokenLayers] = [\n                        \"QmFja2dyb3VuZCAg\",\n                        \"UmFjZSAg\",\n                        \"RmFjZSAg\",\n                        \"TW91dGgg\",\n                        \"Tm9zZSAg\",\n                        \"RXllcyAg\",\n                        \"RWFyIEFjY2Vzc29yeSAg\",\n                        \"RmFjZSBBY2Nlc3Nvcnkg\",\n                        \"TWFzayAg\",\n                        \"SGVhZCBCZWxvdyAg\",\n                        \"RXllIEFjY2Vzc29yeSAg\",\n                        \"SGVhZCBBYm92ZSAg\",\n                        \"TW91dGggQWNjZXNzb3J5\"\n                    ][i];\n                    numTokenLayers++;\n                }\n            }\n        }\n        return (tokenLayers, tokenPalettes, numTokenLayers, traitTypes);\n    }\n\n    /*\n    Generate svg rects, leaving un-concatenated to save a redundant concatenation in calling functions to reduce gas.\n    Shout out to Blitmap for a lot of the inspiration for efficient rendering here.\n    */\n    function tokenSVGBuffer(\n        Layer[NUM_LAYERS] memory tokenLayers,\n        Color[NUM_COLORS][NUM_LAYERS] memory tokenPalettes,\n        uint8 numTokenLayers\n    ) public pure returns (string[4] memory) {\n        // Base64 encoded lookups into x/y position strings from 010 to 310.\n        string[32] memory lookup = [\n            \"MDAw\",\n            \"MDEw\",\n            \"MDIw\",\n            \"MDMw\",\n            \"MDQw\",\n            \"MDUw\",\n            \"MDYw\",\n            \"MDcw\",\n            \"MDgw\",\n            \"MDkw\",\n            \"MTAw\",\n            \"MTEw\",\n            \"MTIw\",\n            \"MTMw\",\n            \"MTQw\",\n            \"MTUw\",\n            \"MTYw\",\n            \"MTcw\",\n            \"MTgw\",\n            \"MTkw\",\n            \"MjAw\",\n            \"MjEw\",\n            \"MjIw\",\n            \"MjMw\",\n            \"MjQw\",\n            \"MjUw\",\n            \"MjYw\",\n            \"Mjcw\",\n            \"Mjgw\",\n            \"Mjkw\",\n            \"MzAw\",\n            \"MzEw\"\n        ];\n        SVGCursor memory cursor;\n\n        /*\n        Rather than concatenating the result string with itself over and over (e.g. result = abi.encodePacked(result, newString)),\n        we fill up multiple levels of buffers.  This reduces redundant intermediate concatenations, performing O(log(n)) concats\n        instead of O(n) concats.  Buffers beyond a length of about 12 start hitting stack too deep issues, so using a length of 8\n        because the pixel math is convenient.\n        */\n        Buffer memory buffer4;\n        // 4 pixels per slot, 32 total.  Struct is ever so slightly better for gas, so using when convenient.\n        string[8] memory buffer32;\n        // 32 pixels per slot, 256 total\n        string[4] memory buffer256;\n        // 256 pixels per slot, 1024 total\n        uint8 buffer32count;\n        uint8 buffer256count;\n        for (uint256 k = 32; k < 416; ) {\n            cursor.color1 = colorForIndex(\n                tokenLayers,\n                k,\n                0,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color2 = colorForIndex(\n                tokenLayers,\n                k,\n                1,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color3 = colorForIndex(\n                tokenLayers,\n                k,\n                2,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color4 = colorForIndex(\n                tokenLayers,\n                k,\n                3,\n                tokenPalettes,\n                numTokenLayers\n            );\n            buffer4.one = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            cursor.color1 = colorForIndex(\n                tokenLayers,\n                k,\n                4,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color2 = colorForIndex(\n                tokenLayers,\n                k,\n                5,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color3 = colorForIndex(\n                tokenLayers,\n                k,\n                6,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color4 = colorForIndex(\n                tokenLayers,\n                k,\n                7,\n                tokenPalettes,\n                numTokenLayers\n            );\n            buffer4.two = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            k += 3;\n\n            cursor.color1 = colorForIndex(\n                tokenLayers,\n                k,\n                0,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color2 = colorForIndex(\n                tokenLayers,\n                k,\n                1,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color3 = colorForIndex(\n                tokenLayers,\n                k,\n                2,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color4 = colorForIndex(\n                tokenLayers,\n                k,\n                3,\n                tokenPalettes,\n                numTokenLayers\n            );\n            buffer4.three = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            cursor.color1 = colorForIndex(\n                tokenLayers,\n                k,\n                4,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color2 = colorForIndex(\n                tokenLayers,\n                k,\n                5,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color3 = colorForIndex(\n                tokenLayers,\n                k,\n                6,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color4 = colorForIndex(\n                tokenLayers,\n                k,\n                7,\n                tokenPalettes,\n                numTokenLayers\n            );\n            buffer4.four = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            k += 3;\n\n            cursor.color1 = colorForIndex(\n                tokenLayers,\n                k,\n                0,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color2 = colorForIndex(\n                tokenLayers,\n                k,\n                1,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color3 = colorForIndex(\n                tokenLayers,\n                k,\n                2,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color4 = colorForIndex(\n                tokenLayers,\n                k,\n                3,\n                tokenPalettes,\n                numTokenLayers\n            );\n            buffer4.five = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            cursor.color1 = colorForIndex(\n                tokenLayers,\n                k,\n                4,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color2 = colorForIndex(\n                tokenLayers,\n                k,\n                5,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color3 = colorForIndex(\n                tokenLayers,\n                k,\n                6,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color4 = colorForIndex(\n                tokenLayers,\n                k,\n                7,\n                tokenPalettes,\n                numTokenLayers\n            );\n            buffer4.six = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            k += 3;\n\n            cursor.color1 = colorForIndex(\n                tokenLayers,\n                k,\n                0,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color2 = colorForIndex(\n                tokenLayers,\n                k,\n                1,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color3 = colorForIndex(\n                tokenLayers,\n                k,\n                2,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color4 = colorForIndex(\n                tokenLayers,\n                k,\n                3,\n                tokenPalettes,\n                numTokenLayers\n            );\n            buffer4.seven = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            cursor.color1 = colorForIndex(\n                tokenLayers,\n                k,\n                4,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color2 = colorForIndex(\n                tokenLayers,\n                k,\n                5,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color3 = colorForIndex(\n                tokenLayers,\n                k,\n                6,\n                tokenPalettes,\n                numTokenLayers\n            );\n            cursor.color4 = colorForIndex(\n                tokenLayers,\n                k,\n                7,\n                tokenPalettes,\n                numTokenLayers\n            );\n            buffer4.eight = pixel4(lookup, cursor);\n            cursor.x += 4;\n\n            k += 3;\n\n            buffer32[buffer32count++] = string(\n                abi.encodePacked(\n                    buffer4.one,\n                    buffer4.two,\n                    buffer4.three,\n                    buffer4.four,\n                    buffer4.five,\n                    buffer4.six,\n                    buffer4.seven,\n                    buffer4.eight\n                )\n            );\n            cursor.x = 0;\n            cursor.y += 1;\n            if (buffer32count >= 8) {\n                buffer256[buffer256count++] = string(\n                    abi.encodePacked(\n                        buffer32[0],\n                        buffer32[1],\n                        buffer32[2],\n                        buffer32[3],\n                        buffer32[4],\n                        buffer32[5],\n                        buffer32[6],\n                        buffer32[7]\n                    )\n                );\n                buffer32count = 0;\n            }\n        }\n        // At this point, buffer256 contains 4 strings or 256*4=1024=32x32 pixels\n        return buffer256;\n    }\n\n    function palette(bytes memory data)\n        internal\n        pure\n        returns (Color[NUM_COLORS] memory)\n    {\n        Color[NUM_COLORS] memory colors;\n        for (uint16 i = 0; i < NUM_COLORS; i++) {\n            // Even though this can be computed later from the RGBA values below, it saves gas to pre-compute it once upfront.\n            colors[i].hexString = Base64.encode(\n                bytes(\n                    abi.encodePacked(\n                        byteToHexString(data[i * 4]),\n                        byteToHexString(data[i * 4 + 1]),\n                        byteToHexString(data[i * 4 + 2])\n                    )\n                )\n            );\n            colors[i].red = byteToUint(data[i * 4]);\n            colors[i].green = byteToUint(data[i * 4 + 1]);\n            colors[i].blue = byteToUint(data[i * 4 + 2]);\n            colors[i].alpha = byteToUint(data[i * 4 + 3]);\n        }\n        return colors;\n    }\n\n    function colorForIndex(\n        Layer[NUM_LAYERS] memory tokenLayers,\n        uint256 k,\n        uint256 index,\n        Color[NUM_COLORS][NUM_LAYERS] memory palettes,\n        uint256 numTokenLayers\n    ) internal pure returns (string memory) {\n        for (uint256 i = 0; i < numTokenLayers; i++) {\n            Color memory fg = palettes[numTokenLayers - 1 - i][\n                colorIndex(\n                    tokenLayers[numTokenLayers - 1 - i].hexString,\n                    k,\n                    index\n                )\n            ];\n            // Since most layer pixels are transparent, performing this check first saves gas\n            if (fg.alpha == 0) {\n                continue;\n            } else if (fg.alpha == 255) {\n                return fg.hexString;\n            } else {\n                if (numTokenLayers - 2 - i >= 0) {\n                    for (uint256 j = numTokenLayers - 2 - i; j >= 0; j--) {\n                        Color memory bg = palettes[j][\n                            colorIndex(tokenLayers[j].hexString, k, index)\n                        ];\n                        /* As a simplification, blend with first non-transparent layer then stop.\n                    We won't generally have overlapping semi-transparent pixels.\n                    */\n                        if (bg.alpha > 0) {\n                            return Base64.encode(bytes(blendColors(fg, bg)));\n                        }\n                    }\n                } else {\n                    return fg.hexString;\n                }\n            }\n        }\n        return Base64.encode(bytes(\"ffffff\"));\n    }\n\n    /*\n    Each color index is 3 bits (there are 8 colors, so 3 bits are needed to index into them).\n    Since 3 bits doesn't divide cleanly into 8 bits (1 byte), we look up colors 24 bits (3 bytes) at a time.\n    \"k\" is the starting byte index, and \"index\" is the color index within the 3 bytes starting at k.\n    */\n    function colorIndex(\n        bytes memory data,\n        uint256 k,\n        uint256 index\n    ) internal pure returns (uint8) {\n        if (index == 0) {\n            return uint8(data[k]) >> 5;\n        } else if (index == 1) {\n            return (uint8(data[k]) >> 2) % 8;\n        } else if (index == 2) {\n            return ((uint8(data[k]) % 4) * 2) + (uint8(data[k + 1]) >> 7);\n        } else if (index == 3) {\n            return (uint8(data[k + 1]) >> 4) % 8;\n        } else if (index == 4) {\n            return (uint8(data[k + 1]) >> 1) % 8;\n        } else if (index == 5) {\n            return ((uint8(data[k + 1]) % 2) * 4) + (uint8(data[k + 2]) >> 6);\n        } else if (index == 6) {\n            return (uint8(data[k + 2]) >> 3) % 8;\n        } else {\n            return uint8(data[k + 2]) % 8;\n        }\n    }\n\n    /*\n    Create 4 svg rects, pre-base64 encoding the svg constants to save gas.\n    */\n    function pixel4(string[32] memory lookup, SVGCursor memory cursor)\n        internal\n        pure\n        returns (string memory result)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    \"PHJlY3QgICBmaWxsPScj\",\n                    cursor.color1,\n                    \"JyAgeD0n\",\n                    lookup[cursor.x],\n                    \"JyAgeT0n\",\n                    lookup[cursor.y],\n                    \"JyAvPjxyZWN0ICBmaWxsPScj\",\n                    cursor.color2,\n                    \"JyAgeD0n\",\n                    lookup[cursor.x + 1],\n                    \"JyAgeT0n\",\n                    lookup[cursor.y],\n                    \"JyAvPjxyZWN0ICBmaWxsPScj\",\n                    cursor.color3,\n                    \"JyAgeD0n\",\n                    lookup[cursor.x + 2],\n                    \"JyAgeT0n\",\n                    lookup[cursor.y],\n                    \"JyAvPjxyZWN0ICBmaWxsPScj\",\n                    cursor.color4,\n                    \"JyAgeD0n\",\n                    lookup[cursor.x + 3],\n                    \"JyAgeT0n\",\n                    lookup[cursor.y],\n                    \"JyAgIC8+\"\n                )\n            );\n    }\n\n    /*\n    Blend colors, inspired by https://stackoverflow.com/a/12016968\n    */\n    function blendColors(Color memory fg, Color memory bg)\n        internal\n        pure\n        returns (string memory)\n    {\n        uint256 alpha = uint16(fg.alpha + 1);\n        uint256 inv_alpha = uint16(256 - fg.alpha);\n        return\n            uintToHexString6(\n                uint24((alpha * fg.blue + inv_alpha * bg.blue) >> 8) +\n                    (uint24((alpha * fg.green + inv_alpha * bg.green) >> 8) <<\n                        8) +\n                    (uint24((alpha * fg.red + inv_alpha * bg.red) >> 8) << 16)\n            );\n    }\n\n    function splitNumber(uint256 _number)\n        internal\n        pure\n        returns (uint16[NUM_LAYERS] memory numbers)\n    {\n        for (uint256 i = 0; i < numbers.length; i++) {\n            numbers[i] = uint16(_number % 10000);\n            _number >>= 14;\n        }\n        return numbers;\n    }\n\n    function uintToHexDigit(uint8 d) public pure returns (bytes1) {\n        if (0 <= d && d <= 9) {\n            return bytes1(uint8(bytes1(\"0\")) + d);\n        } else if (10 <= uint8(d) && uint8(d) <= 15) {\n            return bytes1(uint8(bytes1(\"a\")) + d - 10);\n        }\n        revert();\n    }\n\n    /*\n    Convert uint to hex string, padding to 6 hex nibbles\n    */\n    function uintToHexString6(uint256 a) public pure returns (string memory) {\n        string memory str = uintToHexString2(a);\n        if (bytes(str).length == 2) {\n            return string(abi.encodePacked(\"0000\", str));\n        } else if (bytes(str).length == 3) {\n            return string(abi.encodePacked(\"000\", str));\n        } else if (bytes(str).length == 4) {\n            return string(abi.encodePacked(\"00\", str));\n        } else if (bytes(str).length == 5) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n        return str;\n    }\n\n    /*\n    Convert uint to hex string, padding to 2 hex nibbles\n    */\n    function uintToHexString2(uint256 a) public pure returns (string memory) {\n        uint256 count = 0;\n        uint256 b = a;\n        while (b != 0) {\n            count++;\n            b /= 16;\n        }\n        bytes memory res = new bytes(count);\n        for (uint256 i = 0; i < count; ++i) {\n            b = a % 16;\n            res[count - i - 1] = uintToHexDigit(uint8(b));\n            a /= 16;\n        }\n\n        string memory str = string(res);\n        if (bytes(str).length == 0) {\n            return \"00\";\n        } else if (bytes(str).length == 1) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n        return str;\n    }\n\n    /*\n    Convert uint to byte string, padding number string with spaces at end.\n    Useful to ensure result's length is a multiple of 3, and therefore base64 encoding won't\n    result in '=' padding chars.\n    */\n    function uintToByteString(uint256 a, uint256 fixedLen)\n        internal\n        pure\n        returns (bytes memory _uintAsString)\n    {\n        uint256 j = a;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(fixedLen);\n        j = fixedLen;\n        if (a == 0) {\n            bstr[0] = \"0\";\n            len = 1;\n        }\n        while (j > len) {\n            j = j - 1;\n            bstr[j] = bytes1(\" \");\n        }\n        uint256 k = len;\n        while (a != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(a - (a / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            a /= 10;\n        }\n        return bstr;\n    }\n\n    function byteToUint(bytes1 b) public pure returns (uint256) {\n        return uint256(uint8(b));\n    }\n\n    function byteToHexString(bytes1 b) public pure returns (string memory) {\n        return uintToHexString2(byteToUint(b));\n    }\n}\n\n/// [MIT License]\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    bytes internal constant TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\n                )\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n"
    },
    "contracts/runners/ChainRunnersLayerRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ChainRunnersBaseRenderer.sol\";\n\ncontract ChainRunnersLayerRenderer is ChainRunnersBaseRenderer {\n    function traitSVG(uint8 layerIndex, uint8 itemIndex)\n        public\n        view\n        returns (string memory)\n    {\n        Layer[NUM_LAYERS] memory tokenLayers;\n        Color[NUM_COLORS][NUM_LAYERS] memory tokenPalettes;\n        Layer memory layer = getLayer(layerIndex, itemIndex);\n\n        tokenLayers[0] = layer;\n        tokenPalettes[0] = palette(tokenLayers[0].hexString);\n        string[4] memory buffer256 = tokenSVGBuffer(\n            tokenLayers,\n            tokenPalettes,\n            1\n        );\n        return\n            string(\n                abi.encodePacked(\n                    \"PHN2ZyB2ZXJzaW9uPScxLjEnIHZpZXdCb3g9JzAgMCAzMjAgMzIwJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHNoYXBlLXJlbmRlcmluZz0nY3Jpc3BFZGdlcycgaGVpZ2h0PScxMDAlJyB3aWR0aD0nMTAwJSc+\",\n                    buffer256[0],\n                    buffer256[1],\n                    buffer256[2],\n                    buffer256[3],\n                    \"PHN0eWxlPnJlY3R7d2lkdGg6MTBweDtoZWlnaHQ6MTBweDt9PC9zdHlsZT48L3N2Zz4=\"\n                )\n            );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}